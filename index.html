<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Luxriot support assitant</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Titillium+Web:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700&display=swap');

    :root{
      --bg:#0e0f11;
      --panel:#16181c;
      --panel2:#14161a;
      --border:#262a31;
      --text:#d6d9df;
      --muted:#8a9099;
      --accent:#3fa37c;
      --danger:#d85c5c;
      --ok:#69d17a;
      --warn:#d8b15c;
      --docs-heading-font:"IBM Plex Sans","Source Sans 3","Segoe UI",system-ui,sans-serif;
      --docs-body-font:"Source Sans 3","Segoe UI",system-ui,sans-serif;
    }
    *{box-sizing:border-box}
	    html, body{height:100%;}
	    body{
	      margin:0;
	      min-height:100vh;
	      height:calc(var(--vh, 1vh) * 100);
	      overflow:hidden;
	      background:var(--bg);
	      color:var(--text);
	      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
	    }
    @supports(height:100dvh){
      body{height:100dvh;}
    }
    .app{
      position:relative;height:100%;padding:24px;border:1px solid var(--border);border-radius:16px;
    }

    /* Header */
    .header{display:flex;justify-content:space-between;align-items:center;font-size:14px;color:var(--muted);}
    .logo{display:flex;gap:10px;align-items:center}
    .logo-dot{width:14px;height:14px;background:var(--accent);border-radius:4px}
    .brand{font-weight:700;font-size:22px;color:var(--text);letter-spacing:.5px;font-style:italic}
    .brand-stack{display:flex;flex-direction:column;gap:2px;line-height:1.1}
    .brand-version{font-size:11px;color:var(--muted);letter-spacing:.2px;font-style:normal}
    .header-right{display:flex;align-items:center;gap:14px;}

    /* Center state */
    .center{
      position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
      pointer-events:none;text-align:center;color:var(--muted);font-size:18px;
    }

    /* Bottom dock (actions + prompt) */
    .dock{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:calc(24px + env(safe-area-inset-bottom));
      width:min(980px, 86%);
      display:grid;
      grid-template-areas:"actions input";
      grid-template-columns:auto 1fr;
      gap:16px;
      align-items:end;
      z-index:20;
    }
	    .dock.state-stack{
	      grid-template-areas:"input" "actions";
	      grid-template-columns:1fr;
	      gap:12px;
	    }
	    .dock.state-input-small{
	      gap:12px;
	    }
	    .dock.state-input-small .input-wrap{
	      gap:12px;
	    }
	    .dock.state-input-small .input-area{
	      padding:16px;
	      min-height:84px;
	    }
	    .dock.state-input-small .send{
	      padding:11px 16px;
	    }
	    .input-wrap{
	      grid-area:input;
	      position:relative;
	      left:auto;bottom:auto;transform:none;
	      width:auto;
      display:flex;
      align-items:flex-end;
      gap:16px;
      min-width:0;
    }
    .input-area{
      flex:1;background:var(--panel);border:1px solid var(--border);border-radius:16px;
      padding:18px;min-height:92px;color:var(--text);
      min-width:0;
    }
    .input-area:focus{outline:none;}
    .input-area[contenteditable="true"]:empty:before{
      content: attr(data-placeholder);
      color: var(--muted);
      opacity: .9;
    }
    .send{
      background:rgba(63,163,124,.35);border:1px solid rgba(63,163,124,.45);
      color:var(--text);border-radius:24px;padding:12px 20px;cursor:pointer;
    }

    /* Actions */
    .actions-left{
      grid-area:actions;
      position:relative;
      display:flex;
      gap:14px;
      align-items:center;
      flex-wrap:nowrap;
      z-index:11;
    }
    .dock.state-actions-wrap .actions-left{
      flex-wrap:wrap;
      max-width:var(--dock-actions-wrap-w, 200px);
    }
	    .dock.state-stack .actions-left{
	      justify-content:center;
	      flex-wrap:nowrap;
	      overflow-x:auto;
	      padding-bottom:2px;
	      max-width:none;
	      width:100%;
	    }
    .action{
      position:relative;
      width:var(--action-size,46px);height:var(--action-size,46px);
      border-radius:50%;background:var(--panel);border:1px solid var(--border);
      display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;
    }
    .icon-btn .pdf-label{
      font-size:10px;
      font-weight:700;
      letter-spacing:.4px;
      color:var(--text);
    }
    .icon-btn .icon-label{
      font-size:16px;
      line-height:1;
    }

    /* Small pop panels (history) */
    .mini-panel{
      position:absolute;left:0;bottom:calc(var(--action-size,46px) + 12px);width:260px;background:var(--panel);
      border:1px solid var(--border);border-radius:14px;padding:14px;display:none;
      font-size:13px;color:var(--muted);
    }
    .mini-panel.visible{display:block}
    .mini-panel .title{font-size:13px;color:var(--text);margin-bottom:10px;opacity:.9;}
    .mini-item{padding:8px 0;border-bottom:1px solid var(--border);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .mini-item:last-child{border-bottom:none}

    /* Overlay */
	    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.0);display:none;z-index:90;}
	    .overlay.visible{display:block}

    /* Modal panels shared */
    .modal{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      top:72px;
      bottom:calc(var(--dock-inset, 180px) + 18px);
      width:min(980px, 86%);
      background:linear-gradient(180deg, rgba(22,24,28,.92), rgba(20,22,26,.92));
      border:1px solid var(--border);border-radius:18px;padding:18px 18px 16px;
      box-shadow:0 20px 60px rgba(0,0,0,.45);
      display:none;backdrop-filter: blur(8px);
      z-index:100;
      overflow:hidden;
      flex-direction:column;
    }
    .modal.visible{display:flex}
    .modal-header{font-size:18px;color:var(--text);opacity:.92;margin-bottom:14px;}

    .btn{
      border-radius:26px;padding:10px 18px;cursor:pointer;font-size:12px;letter-spacing:.4px;
      border:1px solid rgba(63,163,124,.45);background:rgba(63,163,124,.25);color:var(--text);
    }
    .btn.ghost{background:rgba(63,163,124,.15);border-color:rgba(63,163,124,.30);}
    .btn.primary{background:rgba(63,163,124,.40);border-color:rgba(63,163,124,.55);}
    .btn.danger{background:rgba(216,92,92,.18);border-color:rgba(216,92,92,.35);}
    .btn.small{padding:8px 12px;border-radius:18px;font-size:11px;}
    .btn.toggled{background:rgba(63,163,124,.32);border-color:rgba(63,163,124,.65);}

    /* Admin panel */
    .admin-grid{
      display:grid;grid-template-columns:1fr 1fr;gap:22px;font-size:13px;color:var(--muted);
      line-height:1.8;padding:4px 6px 10px;
    }
    .admin-grid .span2{grid-column:1 / -1;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
    .row{padding:4px 0;white-space:normal;overflow:hidden;text-overflow:ellipsis;}
    .slash{color:rgba(214,217,223,.75)}
    .kbd{color:rgba(214,217,223,.85)}
    .admin-actions{display:flex;justify-content:flex-end;gap:14px;margin-top:8px;padding-right:6px;}

	    /* Admin modal internal scroll */
	    #adminPanel .admin-grid{
	      flex:1;
	      min-height:0;
	      overflow:auto;
	      padding-right:12px;
	    }
	    #adminPanel .admin-actions{flex:0 0 auto;}

	    /* Redactor modal internal scroll */
	    #redactorPanel .redactor-grid{
	      flex:1;
	      min-height:0;
	      overflow:auto;
	      padding:4px 6px 10px;
	    }

	    /* Docs reader modal */
	    #docsPanel.light{
	      --text:#1a1b1e;
	      --muted:#55606d;
	      --border:rgba(0,0,0,.14);
      --panel:rgba(255,255,255,.95);
      --panel2:rgba(245,246,248,.95);
      background:linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow:0 20px 60px rgba(0,0,0,.18);
    }
    #docsPanel.light .card{
      background:rgba(255,255,255,.72);
    }
    #docsPanel.light input[type="text"],
    #docsPanel.light textarea,
    #docsPanel.light select{
      background:rgba(255,255,255,.92);
      border-color:rgba(0,0,0,.12);
      color:var(--text);
    }
    #docsPanel.light .docs-item{
      background:rgba(255,255,255,.72);
    }
    #docsPanel.light .docs-item:hover{border-color:rgba(0,0,0,.20);}
    #docsPanel.light .docsPage code{
      background:rgba(0,0,0,.05);
      border-color:rgba(0,0,0,.12);
      color:var(--text);
    }
    #docsPanel.light .docsPage pre{
      background:rgba(0,0,0,.04);
      border-color:rgba(0,0,0,.12);
    }
    #docsPanel.light .docsPage th{background:rgba(0,0,0,.04);}
    #docsPanel.light .docs-edit-preview{
      background:rgba(255,255,255,.82);
    }
    #docsPanel.light .docs-edit-text{
      background:rgba(255,255,255,.92);
      border-color:rgba(0,0,0,.12);
      color:var(--text);
    }
    #docsPanel.light .docs-edit-preview code{
      background:rgba(0,0,0,.05);
      border-color:rgba(0,0,0,.12);
      color:var(--text);
    }
    #docsPanel.light .docs-edit-preview pre{
      background:rgba(0,0,0,.04);
      border-color:rgba(0,0,0,.12);
    }
    #docsPanel.light .docs-edit-preview th{background:rgba(0,0,0,.04);}
    #docsPanel.nav-collapsed .docs-grid{grid-template-columns:1fr;}
    #docsPanel.nav-collapsed .docs-nav{display:none;}
    #docsPanel.fullscreen{
      left:24px;
      right:24px;
      top:24px;
      bottom:24px;
      transform:none;
      width:auto;
      max-height:none;
    }
    .docs-grid{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap:18px;
      flex:1;
      min-height:0;
      padding:4px 6px 10px;
    }
	    .docs-nav{
	      display:flex;
	      flex-direction:column;
	      min-width:0;
	      min-height:0;
	      overflow:hidden;
	    }
	    .docs-version-row{
	      display:flex;
	      align-items:center;
	      gap:8px;
	    }
	    .docs-version-row select{flex:1;}
	    .docs-actions{
	      display:flex;
	      flex-wrap:wrap;
	      gap:8px;
	      margin:8px 0 6px;
	    }
    .docs-list{
      flex:1;
      min-height:0;
      overflow:auto;
      padding-right:6px;
      margin-top:8px;
    }
    .docs-item{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 10px;
      margin-bottom:10px;
      background:rgba(16,17,19,.35);
      cursor:pointer;
      user-select:none;
    }
    .docs-item:hover{border-color:rgba(214,217,223,.25);}
    .docs-item.active{
      border-color:rgba(63,163,124,.45);
      background:rgba(63,163,124,.12);
    }
    .docs-item .top{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      font-size:12px;
      color:var(--text);
      opacity:.94;
    }
    .docs-item .sub{
      margin-top:6px;
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
		    .docs-content{
		      display:flex;
		      flex-direction:column;
		      min-width:0;
		      min-height:0;
		      overflow:hidden;
		    }
	    .docs-toolbar{
	      display:flex;
	      justify-content:space-between;
	      gap:12px;
	      align-items:center;
	      flex-wrap:wrap;
	      margin-bottom:10px;
	    }
	    #docsBreadcrumb{flex:1;min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
	    .docs-controls{display:flex;align-items:center;gap:10px;flex:0 0 auto;}
    .icon-btn{
      width:36px;height:36px;border-radius:999px;
      border:1px solid rgba(63,163,124,.30);
      background:rgba(63,163,124,.14);
      color:var(--text);
	      display:inline-flex;align-items:center;justify-content:center;
	      cursor:pointer;
	      padding:0;
	    }
	    .icon-btn:hover{background:rgba(63,163,124,.20);border-color:rgba(63,163,124,.45);}
    .icon-btn svg{width:18px;height:18px;fill:currentColor;opacity:.92;}
    .icon-btn .icon{display:none;}
    #docsPanel:not(.fullscreen) #docsFullscreenBtn .icon-enter{display:block;}
    #docsPanel.fullscreen #docsFullscreenBtn .icon-exit{display:block;}
    #docsPanel.light #docsThemeBtn .icon-moon{display:block;}
    #docsPanel:not(.light) #docsThemeBtn .icon-sun{display:block;}
    #docsPanel.nav-collapsed #docsNavToggleBtn .icon-expand{display:block;}
    #docsPanel:not(.nav-collapsed) #docsNavToggleBtn .icon-collapse{display:block;}
    .docsPage{
      flex:1;
      min-height:0;
      overflow:auto;
      padding-right:10px;
      font-family:var(--docs-body-font);
      font-size:14px;
      line-height:1.6;
      color:var(--text);
      overflow-wrap:anywhere;
      font-variant-ligatures:none !important;
      font-feature-settings:"liga" 0, "calt" 0, "clig" 0, "rlig" 0, "dlig" 0 !important;
    }
    .docsPage p{margin:0 0 14px;}
    .docsPage p:last-child{margin-bottom:0;}
    .docsPage h1,.docsPage h2,.docsPage h3,.docsPage h4,.docsPage h5,.docsPage h6{
      font-family:var(--docs-heading-font);
      margin:20px 0 12px;
      line-height:1.25;
    }
    .docsPage h1{font-size:22px;}
    .docsPage h2{font-size:18px;}
    .docsPage h3{font-size:17px;}
    .docsPage h4{font-size:15px;}
    .docsPage h5{font-size:14px;}
    .docsPage h6{font-size:13px;}
    .docsPage h1:first-child,.docsPage h2:first-child,.docsPage h3:first-child,.docsPage h4:first-child,.docsPage h5:first-child,.docsPage h6:first-child{margin-top:0;}
    .docsPage ul,.docsPage ol{margin:6px 0 10px 20px;padding:0;}
    .docsPage li{margin:4px 0;}
    .docsPage code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:rgba(255,255,255,.06);padding:2px 5px;border-radius:8px;border:1px solid var(--border);}
    .docsPage pre{margin:10px 0;padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:rgba(0,0,0,.25);overflow:auto;}
    .docsPage pre code{display:block;padding:0;border:none;background:transparent;}
    .docsPage a{color:var(--accent);text-decoration:none;}
    .docsPage a:hover{text-decoration:underline;}
    .docsPage hr{border:none;border-top:1px solid var(--border);margin:12px 0;}
		    .docsPage img{max-width:100%;height:auto;display:block;border-radius:14px;border:1px solid var(--border);margin:10px 0;}
		    .docsPage table{width:100%;border-collapse:collapse;margin:10px 0;border:1px solid var(--border);border-radius:12px;overflow:hidden;table-layout:fixed;}
		    .docsPage th,.docsPage td{border:1px solid var(--border);padding:6px 8px;vertical-align:top;font-size:12px;word-break:break-word;}
    .docsPage th{background:rgba(255,255,255,.06);color:var(--text);font-weight:600;}
    .docsPage blockquote{
      margin:10px 0;
      padding:8px 12px;
      border-left:3px solid rgba(214,217,223,.35);
      background:rgba(255,255,255,.04);
      border-radius:10px;
      color:var(--muted);
    }
    .docsPage blockquote p{margin:0 0 6px;}
    .docsPage blockquote p:last-child{margin-bottom:0;}
    .docsPage .admonition{
      margin:12px 0;
      padding:10px 12px;
      border-left:3px solid rgba(63,163,124,.45);
      border-radius:12px;
      background:rgba(63,163,124,.08);
    }
    .docsPage .admonition.warning{border-left-color:rgba(216,92,92,.55);background:rgba(216,92,92,.08);}
    .docsPage .admonition.info{border-left-color:rgba(88,155,219,.55);background:rgba(88,155,219,.08);}
    .docsPage .admonition-title{font-weight:600;margin-bottom:6px;}
    .docsPage .admonition-body p{margin:0 0 6px;}
    .docsPage .admonition-body p:last-child{margin-bottom:0;}
    .docsPage h1,.docsPage h2,.docsPage h3,.docsPage h4,.docsPage h5,.docsPage h6{scroll-margin-top:16px;}
    .docsPage .anchor-hit{
      box-shadow:0 0 0 2px rgba(63,163,124,.55);
      background:rgba(63,163,124,.10);
      border-radius:12px;
      padding:2px 6px;
    }

    .docs-content.editing .docsPage{display:none;}
    .docs-editor{
      display:none;
      flex:1;
      min-height:0;
      flex-direction:column;
      gap:12px;
    }
    .docs-content.editing .docs-editor{display:flex;}
    .docs-cover-editor{
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px 10px;
      background:rgba(255,255,255,.02);
    }
    .docs-cover-editor summary{
      cursor:pointer;
      font-weight:600;
      color:var(--text);
      margin-bottom:8px;
    }
    .docs-cover-editor[open] summary{margin-bottom:12px;}
    .docs-cover-fields{display:grid;gap:8px;}
    .docs-cover-disabled{
      display:none;
      font-size:11px;
      color:var(--muted);
      margin-bottom:8px;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .docs-cover-editor.disabled .docs-cover-fields{display:none;}
    .docs-cover-editor.disabled .docs-cover-disabled{display:flex;}
    .docs-cover-preview{
      margin-top:12px;
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px 18px;
      background:rgba(0,0,0,.18);
      text-align:center;
    }
    .docs-cover-preview .cover-type{
      font-size:11px;
      letter-spacing:.14em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:700;
      margin-bottom:10px;
    }
    .docs-cover-preview .cover-title{
      font-family:var(--docs-heading-font);
      font-size:22px;
      font-weight:700;
      margin-bottom:12px;
      line-height:1.2;
    }
    .docs-cover-preview .cover-image{
      display:flex;
      justify-content:center;
      margin:10px 0 14px;
    }
    .docs-cover-preview .cover-image img{
      max-width:70%;
      max-height:180px;
      border-radius:10px;
      border:1px solid var(--border);
    }
    .docs-cover-preview .cover-text{
      font-size:13px;
      color:var(--muted);
      margin-bottom:10px;
      line-height:1.4;
    }
    .docs-cover-preview .cover-footer{
      font-size:11px;
      color:var(--muted);
      line-height:1.3;
    }
    .docs-edit-tools{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .docs-edit-body{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      flex:1;
      min-height:0;
    }
    .docs-edit-text{
      min-height:0;
      height:100%;
      resize:none;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      font-size:12px;
      line-height:1.4;
      font-variant-ligatures:none !important;
      font-feature-settings:"liga" 0, "calt" 0, "clig" 0, "rlig" 0, "dlig" 0 !important;
    }
    .docs-edit-preview{
      min-height:0;
      overflow:auto;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(16,17,19,.35);
    }
    .docs-edit-preview{
      font-family:var(--docs-body-font);
      font-size:14px;
      line-height:1.6;
      font-variant-ligatures:none !important;
      font-feature-settings:"liga" 0, "calt" 0, "clig" 0, "rlig" 0, "dlig" 0 !important;
    }
    .docs-edit-preview p{margin:0 0 14px;}
    .docs-edit-preview p:last-child{margin-bottom:0;}
    .docs-edit-preview ul,.docs-edit-preview ol{margin:6px 0 10px 20px;padding:0;}
    .docs-edit-preview li{margin:4px 0;}
    .docs-edit-preview code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:rgba(255,255,255,.06);padding:2px 5px;border-radius:8px;border:1px solid var(--border);}
    .docs-edit-preview pre{margin:10px 0;padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:rgba(0,0,0,.25);overflow:auto;}
    .docs-edit-preview pre code{display:block;padding:0;border:none;background:transparent;}
    .docs-edit-preview a{color:var(--accent);text-decoration:none;}
    .docs-edit-preview a:hover{text-decoration:underline;}
    .docs-edit-preview hr{border:none;border-top:1px solid var(--border);margin:12px 0;}
    .docs-edit-preview table{width:100%;border-collapse:collapse;margin:10px 0;border:1px solid var(--border);border-radius:12px;overflow:hidden;table-layout:fixed;}
    .docs-edit-preview th,.docs-edit-preview td{border:1px solid var(--border);padding:6px 8px;vertical-align:top;font-size:12px;word-break:break-word;}
    .docs-edit-preview th{background:rgba(255,255,255,.06);color:var(--text);font-weight:600;}
    .docs-edit-actions{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap;}
    .docs-edit-status{font-size:11px;color:var(--muted);}
    .docs-edit-preview h1,.docs-edit-preview h2,.docs-edit-preview h3,.docs-edit-preview h4,.docs-edit-preview h5,.docs-edit-preview h6{
      font-family:var(--docs-heading-font);
      margin:20px 0 12px;
      line-height:1.25;
    }
    .docs-edit-preview h1{font-size:22px;}
    .docs-edit-preview h2{font-size:18px;}
    .docs-edit-preview h3{font-size:17px;}
    .docs-edit-preview h4{font-size:15px;}
    .docs-edit-preview h5{font-size:14px;}
    .docs-edit-preview h6{font-size:13px;}
    .docs-edit-preview h1:first-child,.docs-edit-preview h2:first-child,.docs-edit-preview h3:first-child,.docs-edit-preview h4:first-child,.docs-edit-preview h5:first-child,.docs-edit-preview h6:first-child{margin-top:0;}
    .docs-style-preview{
      margin-top:10px;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:12px;
      background:rgba(255,255,255,.03);
    }
    .docs-style-preview .preview-heading{
      font-family:var(--docs-heading-font);
      font-size:16px;
      font-weight:700;
      margin-bottom:6px;
    }
    .docs-style-preview .preview-body{
      font-family:var(--docs-body-font);
      font-size:13px;
      color:var(--muted);
    }
    .docs-style-preview .preview-body span{
      display:inline-block;
      margin-right:8px;
      color:var(--text);
    }
    .docs-edit-preview img{max-width:100%;height:auto;display:block;border-radius:14px;border:1px solid var(--border);margin:10px 0;}
    .docs-edit-preview blockquote{margin:10px 0;padding:8px 12px;border-left:3px solid rgba(214,217,223,.35);background:rgba(255,255,255,.04);border-radius:10px;color:var(--muted);}
    .docs-edit-preview .admonition{margin:12px 0;padding:10px 12px;border-left:3px solid rgba(63,163,124,.45);border-radius:12px;background:rgba(63,163,124,.08);}
    .docs-edit-preview .admonition.warning{border-left-color:rgba(216,92,92,.55);background:rgba(216,92,92,.08);}
    .docs-edit-preview .admonition.info{border-left-color:rgba(88,155,219,.55);background:rgba(88,155,219,.08);}
    .docs-edit-preview .admonition-title{font-weight:600;margin-bottom:6px;}
    .docs-edit-preview .admonition-body p{margin:0 0 6px;}
    .docs-edit-preview .admonition-body p:last-child{margin-bottom:0;}

	    /* Retrieval debug modal internal scroll */
	    .debug-body{
	      flex:1;
	      min-height:0;
	      overflow:auto;
	      padding:4px 6px 10px;
	    }
    .debug-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:18px;
      align-items:start;
    }
    .debug-results{
      max-height:520px;
      overflow:auto;
      padding-right:10px;
    }
    .debug-row{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      margin-bottom:10px;
      background:rgba(16,17,19,.35);
    }
    .debug-row .top{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      font-size:12px;
      color:var(--text);
      opacity:.94;
    }
    .debug-kv{font-size:11px;color:var(--muted);margin-top:6px;line-height:1.5;}
    .debug-kv .k{color:rgba(214,217,223,.78);}
    .debug-snippet{margin-top:8px;font-size:12px;color:var(--text);opacity:.92;white-space:pre-wrap;}

    /* Redactor panel */
    .redactor-grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:18px;
      align-items:start;
    }
    .card{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(22,24,28,.55);
      padding:14px;
    }
    .card > h3{
      margin:0 0 10px 0;
      font-size:13px;
      color:var(--text);
      opacity:.9;
      font-weight:600;
      letter-spacing:.2px;
    }
    label{font-size:12px;color:var(--muted);display:block;margin:10px 0 6px;}
	    input[type="text"], input[type="password"], input[type="number"], textarea, select{
	      width:100%;
	      background:rgba(16,17,19,.65);
	      border:1px solid var(--border);
	      border-radius:10px;
	      color:var(--text);
      padding:10px 10px;
      outline:none;
      font-size:12px;
    }
    textarea{min-height:90px;resize:vertical;}
    .inline{
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
    }
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      border:1px solid var(--border);border-radius:999px;padding:6px 10px;
      background:rgba(16,17,19,.45);
      font-size:12px;color:var(--muted);
      user-select:none;
    }
    .pill input{accent-color: var(--accent);}
    .meter{
      display:flex;gap:10px;align-items:center;
    }
    input[type="range"]{width:100%;}
    .tiny{font-size:11px;color:var(--muted);opacity:.95;}
    .hr{height:1px;background:var(--border);margin:12px 0;}
    .right-col-controls{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
    }
    .list{
      max-height:360px;overflow:auto;padding-right:6px;
    }
	    .item{
	      border:1px solid var(--border);
	      border-radius:12px;
	      padding:10px;
	      margin-bottom:10px;
	      background:rgba(16,17,19,.35);
	      cursor:pointer;
	    }
	    .item.selected{
	      border-color:rgba(63,163,124,.55);
	      box-shadow:0 0 0 2px rgba(63,163,124,.16) inset;
	    }
	    .item.disabled{opacity:.65;}
	    .item .top{
	      display:flex;justify-content:space-between;gap:10px;align-items:center;
	      font-size:12px;
	    }
    .badge{
      padding:4px 8px;border-radius:999px;border:1px solid var(--border);
      font-size:11px;color:var(--muted);
    }
    .score{
      color:var(--text);
      border-color:rgba(63,163,124,.35);
      background:rgba(63,163,124,.10);
    }
    .tagline{margin-top:6px;font-size:11px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .muted{color:var(--muted)}
    .stack{display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;margin-top:12px;}

    /* User settings panel */
	    .user-settings{
	      position:absolute;top:56px;right:24px;width:280px;background:var(--panel);
	      border:1px solid var(--border);border-radius:14px;padding:14px;font-size:13px;color:var(--muted);
	      display:none;
	      z-index:60;
	      max-height:calc(100vh - 110px);
	      overflow:auto;
	    }
    .user-settings.visible{display:block}
    .user-settings .title{color:var(--text);margin-bottom:10px;opacity:.9}
    .user-settings .row2{padding:6px 0;border-bottom:1px solid var(--border)}
    .user-settings .row2:last-child{border-bottom:none}

    /* Chat thread */
    .thread{
      position:absolute;
      left:50%;
      top:72px;
      transform:translateX(-50%);
      width:min(980px, 86%);
      bottom:calc(var(--dock-inset, 180px) + 18px);
      overflow:auto;
      padding:12px 6px 18px;
    }
    .msg{
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px 14px;
      margin:10px 0;
      background:rgba(22,24,28,.85);
    }
	    .msg.user{
	      background:rgba(63,163,124,.12);
	      border-color:rgba(63,163,124,.25);
	    }
	    .msg.user .content{white-space:pre-wrap;}
	    .msg .meta{font-size:12px;color:var(--muted);margin-bottom:8px;}
	    .msg .content{white-space:normal;line-height:1.45;}
	    .msg .content p{margin:0 0 10px;}
	    .msg .content p:last-child{margin-bottom:0;}
	    .msg .content h1,.msg .content h2,.msg .content h3{margin:10px 0 8px;line-height:1.25;}
	    .msg .content h1{font-size:18px;}
	    .msg .content h2{font-size:16px;}
	    .msg .content h3{font-size:14px;}
	    .msg .content ul,.msg .content ol{margin:6px 0 10px 20px;padding:0;}
	    .msg .content li{margin:4px 0;}
	    .msg .content code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:12px;background:rgba(255,255,255,.06);padding:2px 5px;border-radius:8px;border:1px solid var(--border);}
	    .msg .content pre{margin:10px 0;padding:10px 12px;border-radius:12px;border:1px solid var(--border);background:rgba(0,0,0,.25);overflow:auto;}
	    .msg .content pre code{display:block;padding:0;border:none;background:transparent;}
	    .msg .content a{color:var(--accent);text-decoration:none;}
	    .msg .content a:hover{text-decoration:underline;}
	    .msg .content hr{border:none;border-top:1px solid var(--border);margin:12px 0;}
    .msg .content img{max-width:100%;height:auto;border-radius:14px;border:1px solid var(--border);margin:10px 0;}
    .msg .content figure.img-thumb{display:inline-block;max-width:260px;margin:8px 12px 12px 0;vertical-align:top;}
    .msg .content figure.img-thumb a{display:block;text-decoration:none;}
    .msg .content figure.img-thumb img{width:100%;height:auto;border-radius:12px;border:1px solid var(--border);margin:0;box-shadow:0 8px 20px rgba(0,0,0,0.25);}
    .msg .content figure.img-thumb figcaption{margin-top:6px;font-size:11px;color:var(--muted);line-height:1.3;}
    .msg .content .img-thumb-title{font-size:12px;color:var(--text);font-weight:600;margin-bottom:2px;}
	    .msg .content table{width:100%;border-collapse:collapse;margin:10px 0;border:1px solid var(--border);border-radius:12px;overflow:hidden;}
	    .msg .content th,.msg .content td{border:1px solid var(--border);padding:6px 8px;vertical-align:top;font-size:12px;}
	    .msg .content th{background:rgba(255,255,255,.06);color:var(--text);font-weight:600;}
	    .msg .content .cite{color:var(--muted);font-size:12px;padding:0 2px;}
      .msg .actions{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
      .msg .actions .btn{font-size:12px;padding:6px 10px;}
	    .msg.pending{opacity:.95;}
	    .msg.pending .activity{display:flex;align-items:center;gap:10px;color:var(--muted);font-size:13px;}
	    .msg.pending .activity .stop-btn{
	      margin-left:auto;
	      background:rgba(216,92,92,.18);
	      border:1px solid rgba(216,92,92,.35);
	      color:var(--text);
	      border-radius:18px;
	      padding:6px 10px;
	      cursor:pointer;
	      font-size:11px;
	    }
	    .msg.pending .activity .stop-btn:hover{background:rgba(216,92,92,.24);}
	    .msg.pending .activity .stop-btn:disabled{opacity:.6;cursor:default;}
	    .msg.pending .spinner{
	      width:14px;height:14px;border-radius:999px;
	      border:2px solid rgba(214,217,223,.22);
	      border-top-color:rgba(214,217,223,.55);
	      animation:spin 0.9s linear infinite;
	      flex:0 0 auto;
	    }
	    @keyframes spin{to{transform:rotate(360deg)}}
	    .citations{margin-top:10px;display:flex;flex-direction:column;gap:6px;}
	    .citations a{color:var(--accent);text-decoration:none;font-size:12px;}
	    .citations a:hover{text-decoration:underline;}
	    .web-sources{margin-top:10px;display:flex;flex-direction:column;gap:6px;}
	    .web-sources .title{font-size:12px;color:var(--muted);opacity:.95;}
	    .web-sources a{color:var(--accent);text-decoration:none;font-size:12px;}
	    .web-sources a:hover{text-decoration:underline;}
	    .web-sources .snippet{font-size:11px;color:var(--muted);opacity:.95;line-height:1.35;}
	    .web-sources .error{font-size:11px;color:var(--danger);white-space:pre-wrap;}
    .thumb-grid{margin-top:10px;display:flex;flex-wrap:wrap;gap:10px;}
    .thumb{
      width:180px;border:1px solid var(--border);border-radius:12px;overflow:hidden;
      background:#0b0c0e;
    }
    .thumb img{display:block;width:100%;height:auto;}
    .thumb .cap{font-size:11px;padding:6px 8px;color:var(--muted);border-top:1px solid var(--border);}
    .err-details{margin-top:10px;}
    .err-details summary{cursor:pointer;color:var(--danger);font-size:12px;}
    .err-details pre{white-space:pre-wrap;max-height:240px;overflow:auto;background:rgba(0,0,0,.25);padding:10px;border-radius:12px;border:1px solid var(--border);}
    .log-details{margin-top:10px;}
    .log-details summary{cursor:pointer;color:var(--muted);font-size:12px;}
    .log-details pre{white-space:pre-wrap;max-height:240px;overflow:auto;background:rgba(0,0,0,.25);padding:10px;border-radius:12px;border:1px solid var(--border);}

    /* In-panel scrolling */
    .mini-panel{max-height:320px;overflow:auto;}

    /* Custom scrollbars (match chat history look) */
    .app{scrollbar-width:thin;scrollbar-color:rgba(214,217,223,.28) rgba(255,255,255,.06);}
    .app ::-webkit-scrollbar{width:10px;height:10px;}
    .app ::-webkit-scrollbar-track{background:rgba(255,255,255,.06);border-radius:999px;}
    .app ::-webkit-scrollbar-thumb{
      background:rgba(214,217,223,.24);
      border-radius:999px;
      border:2px solid rgba(0,0,0,0);
      background-clip:padding-box;
    }
    .app ::-webkit-scrollbar-thumb:hover{background:rgba(214,217,223,.34);}

    /* Responsive */
	    @media (max-width: 600px){
	      :root{--action-size:42px;}
	      .app{
	        padding:14px 12px;
	        border:none;
	        border-radius:0;
	      }
	      .header{font-size:13px;}
	      .brand{font-size:20px;}

	      .thread{
	        left:12px;
	        right:12px;
	        width:auto;
	        transform:none;
	        top:64px;
	        bottom:calc(var(--dock-inset, 180px) + 12px);
	      }
	      .dock{
	        left:12px;
	        right:12px;
	        width:auto;
	        transform:none;
	        bottom:calc(12px + env(safe-area-inset-bottom));
	        gap:12px;
	      }
	      .actions-left{gap:10px;}
	      .input-wrap{gap:10px;}
	      .input-area{
	        min-height:56px;
	        height:56px;
	        max-height:56px;
	        overflow:auto;
	        padding:12px;
	        border-radius:14px;
	      }
	      .send{
	        padding:10px 14px;
	        border-radius:20px;
	      }
	      .mini-panel{width:min(260px, calc(100vw - 24px));}
	      .modal{
	        left:12px;
	        right:12px;
	        width:auto;
	        transform:none;
	      }
      #docsPanel.fullscreen{
        left:0;
        right:0;
        top:0;
        bottom:0;
      }
      .docs-grid{grid-template-columns: 1fr;}
      .docs-edit-body{grid-template-columns: 1fr;}
    }

    @media (max-width: 380px){
      :root{--action-size:38px;}
      .actions-left{gap:8px;}
      .input-wrap{gap:8px;}
      .send{padding:10px 12px;}
    }

    @media (max-height: 620px){
      .thread{top:60px;}
      .input-area{min-height:48px;height:48px;max-height:48px;}
    }
  </style>
</head>
<body>
<div class="app">

  <div class="header">
    <div class="logo">
      <div class="logo-dot"></div>
      <div class="brand-stack">
        <div class="brand">Luxriot</div>
        <div class="brand-version" id="appVersion">Luxriot SA 0.1.0</div>
      </div>
    </div>

	  <div class="header-right">
		    <div id="userToggle" style="cursor:pointer">Anonymous</div>
		      <div id="topToolToggle" class="action" title="User / Login">ðŸ‘¤</div>
		  </div>
	  </div>

  <div id="thread" class="thread"></div>
  <div id="emptyState" class="center">
    Hi Sasha, I am ready to assist and learn.
  </div>

  <div id="dock" class="dock">
    <!-- Left bottom actions -->
    <div class="actions-left">
      <div class="action" id="historyBtn" title="History">ðŸ•˜
        <div id="historyPanel" class="mini-panel">
          <div class="title">Chat history:</div>
          <div id="historyList"></div>
        </div>
      </div>

      <div class="action" id="toolsBtn" title="Tools">ðŸ› </div>

      <!-- NEW: Docs reader -->
      <div class="action" id="docsBtn" title="Documentation reader">ðŸ“š</div>

      <!-- NEW: Retrieval debug -->
      <div class="action" id="debugBtn" title="Retrieval debug">ðŸ§ª</div>

      <!-- NEW: Redactor panel toggle -->
      <div class="action" id="redactorBtn" title="Redactor / Annotations">âœŽ</div>
    </div>

    <div class="input-wrap">
      <div class="input-area" id="userInput" contenteditable="true" aria-label="User input" data-placeholder="User input"></div>
      <button class="send" id="sendBtn">SEND</button>
    </div>
  </div>

  <div id="overlay" class="overlay"></div>

	  <!-- Admin tools panel -->
	  <div id="adminPanel" class="modal" role="dialog" aria-label="Administrator tools">
	    <div class="modal-header">Administrator tools:</div>
	
	    <div class="admin-grid">
		      <div class="card">
		        <h3>Runtime</h3>
		        <div class="row"><span class="slash">/</span> API base: <span class="kbd" id="adminApiBase">â€”</span></div>
		        <div class="row"><span class="slash">/</span> Docs version: <span class="kbd" id="adminDocsVersion">â€”</span></div>
		        <div class="row"><span class="slash">/</span> Datastore ready: <span class="kbd" id="adminDatastoreReady">â€”</span></div>
		        <div class="row"><span class="slash">/</span> LM Studio: <span class="kbd" id="adminLmstudioUrl">â€”</span></div>
		      </div>

			      <div class="card">
			        <h3>Users</h3>
			        <div class="tiny muted">Admin-only user management (username/email/password + role)</div>
			        <label>New user</label>
			        <div class="inline">
			          <input id="adminNewUserUsername" type="text" placeholder="username" style="flex:1;min-width:160px;"/>
			          <select id="adminNewUserRole" style="width:160px;">
			            <option value="client" selected>client</option>
			            <option value="redactor">redactor</option>
			            <option value="support">support specialist</option>
			            <option value="admin">admin</option>
			          </select>
			        </div>
			        <label>Email (optional)</label>
			        <input id="adminNewUserEmail" type="text" placeholder="name@example.com"/>
			        <label>Password</label>
			        <input id="adminNewUserPassword" type="password" placeholder="min 6 chars"/>
			        <label>Greeting (optional)</label>
			        <input id="adminNewUserGreeting" type="text" placeholder="Welcome message shown to the user"/>
			        <div class="inline" style="margin-top:10px;">
			          <button class="btn ghost small" id="adminUsersRefreshBtn">REFRESH</button>
			          <button class="btn primary small" id="adminUsersCreateBtn">CREATE</button>
			        </div>
			        <div class="tiny muted" id="adminUsersStatus" style="margin-top:10px;"></div>
			        <div class="list" id="adminUsersList" style="max-height:220px;"></div>
		
			        <details class="log-details" id="adminUserEditDetails" style="margin-top:10px;">
			          <summary>Edit selected user</summary>
			          <div class="tiny muted" style="margin-top:10px;">Click a user in the list to edit role/email/greeting or reset password.</div>
		
			          <label style="margin-top:10px;">Username</label>
			          <input id="adminEditUserUsername" type="text" disabled placeholder="â€”"/>
		
			          <label>Email</label>
			          <input id="adminEditUserEmail" type="text" placeholder="name@example.com"/>
		
			        <label>Role</label>
			        <select id="adminEditUserRole">
			          <option value="client">client</option>
			          <option value="support">support specialist</option>
			          <option value="redactor">redactor</option>
			          <option value="admin">admin</option>
			        </select>

			        <label>Docs permissions</label>
			        <div class="inline">
			          <span class="pill"><input id="adminEditUserDocsEdit" type="checkbox"> docs edit</span>
			          <span class="pill"><input id="adminEditUserDocsPublish" type="checkbox"> docs publish</span>
			        </div>
		
			        <label>Status</label>
			        <span class="pill"><input id="adminEditUserDisabled" type="checkbox"> disabled</span>
		
			        <label>Greeting</label>
			        <input id="adminEditUserGreeting" type="text" placeholder="Welcome message shown to the user"/>
		
			          <label>Reset password</label>
			          <input id="adminEditUserPassword" type="password" placeholder="leave empty to keep"/>
		
			          <div class="inline" style="margin-top:10px;">
			            <button class="btn primary small" id="adminEditUserSaveBtn">SAVE</button>
			            <button class="btn ghost small" id="adminEditUserClearBtn">CLEAR</button>
			          </div>
			          <div class="tiny muted" id="adminEditUserStatus" style="margin-top:10px;"></div>
			        </details>
			      </div>

      <div class="card">
        <h3>Docs</h3>
        <label>Docs folder (Help+Manual export root)</label>
        <input id="adminDocsDir" type="text" placeholder="/path/to/docs"/>
	        <div class="inline" style="margin-top:8px;">
	          <span class="pill"><input id="adminIngestEmbeddings" type="checkbox" checked> embeddings</span>
	          <span class="pill"><input id="adminIncludeEdits" type="checkbox" checked> include published edits</span>
	          <div style="flex:1;min-width:160px;">
	            <label style="margin:0 0 6px;">Emb max chars</label>
	            <input id="adminEmbeddingMaxChars" type="number" min="256" max="8000" value="448"/>
	          </div>
	          <div style="flex:1;min-width:120px;">
	            <label style="margin:0 0 6px;">Emb batch</label>
	            <input id="adminEmbeddingBatchSize" type="number" min="1" max="64" value="8"/>
	          </div>
	        </div>
	        <div class="inline" style="margin-top:10px;">
	          <button class="btn danger" id="adminReindexBtn">RE-INDEX</button>
	          <button class="btn ghost" id="adminReindexRefreshBtn">REFRESH</button>
	        </div>
	        <div class="tiny muted" id="adminReindexStatus" style="margin-top:10px;"></div>
        <details class="log-details">
          <summary>Show reindex logs</summary>
          <pre id="adminReindexLogs"></pre>
        </details>
      </div>

      <div class="card" id="adminPublishCard">
        <h3>Publish requests</h3>
        <div class="tiny muted">Pending doc publish requests (admin approval).</div>
        <div class="inline" style="margin-top:8px;">
          <button class="btn ghost small" id="adminPublishRefreshBtn">REFRESH</button>
        </div>
        <div class="tiny muted" id="adminPublishStatus" style="margin-top:10px;"></div>
        <div class="list" id="adminPublishList" style="max-height:220px;"></div>
      </div>

      <div class="card" id="docsStyleCard">
        <h3>Docs style</h3>
        <label>Heading font</label>
        <select id="docsHeadingFont"></select>
        <label>Body font</label>
        <select id="docsBodyFont"></select>
        <div class="docs-style-preview">
          <div class="preview-heading">Heading preview</div>
          <div class="preview-body">
            <span style="font-weight:300;">Light</span>
            <span style="font-weight:400;">Regular</span>
            <span style="font-weight:600;">Bold</span>
          </div>
        </div>
        <label style="margin-top:12px;">Cover guide type</label>
        <input id="docsCoverType" type="text" placeholder="Guide"/>
        <label>Cover image (path or URL)</label>
        <input id="docsCoverImage" type="text" placeholder="/assets/evo_1_32/.../logo.png"/>
        <label>Cover text</label>
        <textarea id="docsCoverText" rows="3" placeholder="Optional summary or subtitle"></textarea>
        <label>Copyright</label>
        <input id="docsCoverCopyright" type="text" placeholder="Â© Luxriot"/>
        <div class="tiny muted" style="margin-top:6px;">Applies to docs reader + PDF export.</div>
      </div>
	
		      <div class="card">
		        <h3>Retrieval</h3>
		        <label>Mode</label>
		        <select id="adminRetrievalMode">
		          <option value="bm25">bm25</option>
		          <option value="embedding">embedding</option>
		          <option value="hybrid">hybrid</option>
		        </select>
		        <label>Default k</label>
		        <input id="adminRetrievalK" type="number" min="1" max="25" value="8"/>
		        <div class="inline">
		          <div style="flex:1;">
	            <label>Max citations</label>
	            <input id="adminMaxCitations" type="number" min="1" max="25" value="8"/>
	          </div>
	          <div style="flex:1;">
	            <label>Max images</label>
		            <input id="adminMaxImages" type="number" min="0" max="12" value="6"/>
		          </div>
		        </div>
		        <label>Doc priority boost (soft)</label>
		        <input id="adminDocPriorityBoost" type="number" step="0.01" min="0" max="1" value="0"/>
		        <label>Heading match boost</label>
		        <input id="adminHeadingBoost" type="number" step="0.05" min="0" max="2" value="0"/>
		        <label>Doc priority (one per line)</label>
		        <textarea id="adminDocPriority" class="mono" style="height:120px;" placeholder="luxriot-evo-global-administration-guide&#10;luxriot-evo-monitor&#10;..."></textarea>
		
		        <details style="margin-top:10px;">
		          <summary class="tiny muted">Advanced retrieval settings</summary>
		          <div class="inline" style="margin-top:10px;">
		            <div style="flex:1;">
		              <label>Max per page</label>
		              <input id="adminMaxPerPage" type="number" min="0" max="20" value="3"/>
		            </div>
		            <div style="flex:1;">
		              <label>Max per doc</label>
		              <input id="adminMaxPerDoc" type="number" min="0" max="50" value="12"/>
		            </div>
		          </div>
		
		          <div class="hr"></div>
		
		          <div class="tiny muted">Hybrid scoring (RRF)</div>
		          <div class="inline" style="margin-top:8px;">
		            <div style="flex:1;">
		              <label>RRF k</label>
		              <input id="adminRrfK" type="number" min="1" max="200" value="60"/>
		            </div>
		            <div style="flex:1;">
		              <label>BM25 weight</label>
		              <input id="adminBm25Weight" type="number" step="0.1" min="0" max="5" value="1.0"/>
		            </div>
		            <div style="flex:1;">
		              <label>Emb weight</label>
		              <input id="adminEmbWeight" type="number" step="0.1" min="0" max="5" value="1.0"/>
		            </div>
		          </div>
		          <div class="inline">
		            <div style="flex:1;">
		              <label>BM25 candidates</label>
		              <input id="adminBm25Candidates" type="number" min="10" max="500" value="120"/>
		            </div>
		            <div style="flex:1;">
		              <label>Emb candidates</label>
		              <input id="adminEmbCandidates" type="number" min="10" max="500" value="120"/>
		            </div>
		          </div>

		          <div class="hr"></div>

		          <div class="tiny muted">Summary routing (two-pass)</div>
		          <div class="inline" style="margin-top:8px;">
		            <span class="pill"><input id="adminSummaryEnabled" type="checkbox" checked> enabled</span>
		          </div>
		          <label>Summary model id</label>
		          <input id="adminSummaryModel" type="text" placeholder="e.g. qwen3-vl-4b"/>
		          <div class="inline" style="margin-top:8px;">
		            <div style="flex:1;">
		              <label>Summary k</label>
		              <input id="adminSummaryK" type="number" min="1" max="50" value="12"/>
		            </div>
		            <div style="flex:1;">
		              <label>Max pages</label>
		              <input id="adminSummaryMaxPages" type="number" min="1" max="100" value="20"/>
		            </div>
		          </div>
		          <div class="inline">
		            <div style="flex:1;">
		              <label>Unit max tokens</label>
		              <input id="adminSummaryUnitTokens" type="number" min="200" max="4000" value="900"/>
		            </div>
		            <div style="flex:1;">
		              <label>Max input chars</label>
		              <input id="adminSummaryMaxChars" type="number" min="500" max="20000" value="6000"/>
		            </div>
		            <div style="flex:1;">
		              <label>Max output tokens</label>
		              <input id="adminSummaryMaxTokens" type="number" min="32" max="1024" value="280"/>
		            </div>
		          </div>

		          <div class="hr"></div>

		          <div class="tiny muted">Diversification (MMR)</div>
		          <div class="inline" style="margin-top:8px;">
		            <span class="pill"><input id="adminMmrEnabled" type="checkbox" checked> enabled</span>
		            <span class="pill"><input id="adminMmrUseEmbeddings" type="checkbox" checked> use embeddings</span>
		          </div>
		          <div class="inline">
		            <div style="flex:1;">
		              <label>MMR Î» (0â€“1)</label>
		              <input id="adminMmrLambda" type="number" step="0.05" min="0" max="1" value="0.8"/>
		            </div>
		            <div style="flex:1;">
		              <label>MMR candidates</label>
		              <input id="adminMmrCandidates" type="number" min="10" max="500" value="80"/>
		            </div>
		          </div>

		          <div class="hr"></div>

		          <div class="tiny muted">Chunk expansion (neighbors)</div>
		          <div class="inline" style="margin-top:8px;">
		            <div style="flex:1;">
		              <label>Neighbors (Â±N)</label>
		              <input id="adminExpandNeighbors" type="number" min="0" max="5" value="1"/>
		            </div>
		            <div style="flex:1;">
		              <label>Max chars per chunk</label>
		              <input id="adminExpandMaxChars" type="number" min="0" max="20000" value="4200"/>
		            </div>
		          </div>
		          <div class="inline" style="margin-top:8px;">
		            <span class="pill"><input id="adminExpandIncludeImages" type="checkbox"> include neighbor images</span>
		          </div>

		          <div class="hr"></div>

		          <div class="tiny muted">Model retrieval loop</div>
		          <div class="inline" style="margin-top:8px;">
		            <span class="pill"><input id="adminToolCallsEnabled" type="checkbox" checked> allow model to request more docs</span>
		            <div style="flex:1;min-width:140px;">
		              <label>Max tool calls</label>
		              <input id="adminToolCallsMax" type="number" min="0" max="20" value="12"/>
		            </div>
		          </div>
		        </details>
		      </div>
	
		      <div class="card span2">
		        <h3>System prompt (transparent)</h3>
		        <div class="tiny muted">
		          Required placeholder: <span class="kbd">{{context}}</span> (context is inserted at runtime)
		        </div>
		        <label>Role</label>
		        <select id="adminPromptRole">
		          <option value="admin">admin</option>
		          <option value="redactor">redactor</option>
		          <option value="support">support specialist</option>
		          <option value="client">client</option>
		          <option value="anonymous">anonymous</option>
		        </select>
		        <label style="margin-top:10px;">Prompt template (for selected role)</label>
		        <textarea id="adminSystemPrompt" class="mono" style="height:220px;"></textarea>
		        <div class="tiny muted" style="margin-top:6px;">Tip: keep templates consistent across roles, but you can loosen tone/tool guidance for admin.</div>
		
		        <details class="err-details" style="margin-top:10px;">
		          <summary>Show rendered preview (without doc context)</summary>
		          <pre id="adminPromptPreview"></pre>
		        </details>
	
	        <div class="tiny muted" id="adminSaveHint" style="margin-top:8px;"></div>
	      </div>
	
		      <div class="card">
		        <h3>LLM</h3>
		        <label>Model ID (optional; blank = auto)</label>
		        <input id="adminModelId" type="text" placeholder="e.g. mistralai/ministral-3-3b"/>
		        <label>Timeout (seconds)</label>
		        <input id="adminTimeoutS" type="number" min="10" max="600" step="5" value="180"/>
		        <label>Temperature</label>
		        <input id="adminTemperature" type="number" step="0.01" min="0" max="2" value="0.2"/>
		        <label>Max tokens</label>
		        <input id="adminMaxTokens" type="number" min="64" max="4096" value="800"/>
		      </div>

	      <div class="card">
	        <h3>Web</h3>
	        <div class="inline" style="margin-top:8px;">
	          <span class="pill"><input id="adminWebEnabled" type="checkbox" checked> enabled</span>
	        </div>
	        <label>Timeout (seconds)</label>
	        <input id="adminWebTimeoutS" type="number" min="2" max="120" step="1" value="15"/>
	        <label>Max chars (per fetch)</label>
	        <input id="adminWebMaxChars" type="number" min="1000" max="50000" step="500" value="20000"/>
	        <label>Max bytes (download)</label>
	        <input id="adminWebMaxBytes" type="number" min="100000" max="5000000" step="50000" value="1000000"/>
	        <div class="inline">
	          <div style="flex:1;">
	            <label>Max URLs per message</label>
	            <input id="adminWebMaxUrls" type="number" min="0" max="5" value="2"/>
	          </div>
	          <div style="flex:1;">
	            <label>Search k</label>
	            <input id="adminWebSearchK" type="number" min="1" max="10" value="5"/>
	          </div>
	        </div>
	        <div class="tiny muted" style="margin-top:8px;">
	          Used when the user pastes a URL, or uses <span class="kbd">search:</span> / <span class="kbd">web:</span>.
	        </div>
	      </div>
	
		      <div class="card">
		        <h3>Notes</h3>
		        <div class="tiny muted">
		          - No prompts are hardcoded in service code.<br/>
		          - Role-based templates are stored in backend settings and selected per logged-in user.
		        </div>
		      </div>
	    </div>
	
	    <div class="admin-actions">
	      <button class="btn ghost" id="defaultsBtn">DEFAULTS</button>
	      <button class="btn" id="applyBtn">APPLY</button>
	      <button class="btn primary" id="adminOkBtn">OK</button>
	    </div>
	  </div>

  <!-- NEW: Redactor panel -->
  <div id="redactorPanel" class="modal" role="dialog" aria-label="Redactor panel">
    <div class="modal-header">Redactor panel:</div>

    <div class="redactor-grid">
      <!-- Left: annotation form -->
      <div class="card">
        <h3>Annotate last answer</h3>

        <div class="tiny muted" id="activeTarget">
          Target: <span class="kbd">last_assistant_message</span>
        </div>

        <label>Score (0â€“10)</label>
        <select id="score">
          <option value="10">10</option><option value="9">9</option><option value="8">8</option>
          <option value="7" selected>7</option><option value="6">6</option><option value="5">5</option>
          <option value="4">4</option><option value="3">3</option><option value="2">2</option>
          <option value="1">1</option><option value="0">0</option>
        </select>

        <label>Tags</label>
        <div class="inline" id="tags">
          <span class="pill"><input type="checkbox" value="correct"> correct</span>
          <span class="pill"><input type="checkbox" value="partially_correct" checked> partially_correct</span>
          <span class="pill"><input type="checkbox" value="wrong"> wrong</span>
          <span class="pill"><input type="checkbox" value="hallucination"> hallucination</span>
          <span class="pill"><input type="checkbox" value="needs_citations"> needs_citations</span>
          <span class="pill"><input type="checkbox" value="noncompliant"> noncompliant</span>
          <span class="pill"><input type="checkbox" value="style_issue"> style_issue</span>
          <span class="pill"><input type="checkbox" value="unsafe"> unsafe</span>
          <span class="pill"><input type="checkbox" value="too_long"> too_long</span>
          <span class="pill"><input type="checkbox" value="too_short"> too_short</span>
        </div>

        <div class="hr"></div>

        <label>Whatâ€™s right (keep)</label>
        <textarea id="right" placeholder="Short bullets: what is correct/useful and should remain."></textarea>

        <label>Whatâ€™s wrong (fix)</label>
        <textarea id="wrong" placeholder="Short bullets: what is incorrect/missing/misleading."></textarea>

        <label>Golden fix (optional)</label>
        <textarea id="golden" placeholder="Corrected answer (or corrected fragments). High-value training signal."></textarea>

        <label>Reviewer confidence</label>
        <div class="meter">
          <input id="confidence" type="range" min="0" max="100" value="80">
          <div class="tiny"><span id="confVal">0.80</span></div>
        </div>

        <div class="inline" style="margin-top:10px;justify-content:space-between;">
          <span class="pill">
            <input id="includeContext" type="checkbox" checked>
            include full context on export
          </span>
          <button class="btn primary" id="saveAnnotationBtn">SAVE ANNOTATION</button>
        </div>

        <div class="tiny" id="saveHint" style="margin-top:10px;opacity:.9;"></div>
      </div>

      <!-- Right: triage + export -->
      <div class="card">
        <h3>Triage & export</h3>

        <div class="right-col-controls">
          <div class="inline">
            <label style="margin:0;">Filter tag</label>
            <select id="filterTag" style="width:180px;">
              <option value="">(any)</option>
              <option value="correct">correct</option>
              <option value="partially_correct">partially_correct</option>
              <option value="wrong">wrong</option>
              <option value="hallucination">hallucination</option>
              <option value="unsafe">unsafe</option>
              <option value="needs_citations">needs_citations</option>
              <option value="noncompliant">noncompliant</option>
              <option value="style_issue">style_issue</option>
              <option value="too_long">too_long</option>
              <option value="too_short">too_short</option>
            </select>
          </div>

          <div class="inline">
            <label style="margin:0;">Sort</label>
            <select id="sortBy" style="width:160px;">
              <option value="newest" selected>newest</option>
              <option value="oldest">oldest</option>
              <option value="score_low">score (low)</option>
              <option value="score_high">score (high)</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="list" id="annoList"></div>

        <div class="stack">
          <button class="btn ghost small" id="exportJsonlBtn">EXPORT JSONL</button>
          <button class="btn ghost small" id="exportCsvBtn">EXPORT CSV</button>
          <button class="btn danger small" id="clearBtn">CLEAR LIST</button>
          <button class="btn primary small" id="redactorOkBtn">OK</button>
        </div>
      </div>
    </div>
  </div>

  <!-- NEW: Docs reader panel -->
  <div id="docsPanel" class="modal" role="dialog" aria-label="Documentation reader">
    <div class="modal-header">Documentation:</div>

    <div class="docs-grid">
      <div class="card docs-nav">
        <h3>Guides</h3>
        <label>Version</label>
        <div class="docs-version-row">
          <select id="docsVersionSelect"></select>
        </div>

        <div class="docs-actions" id="docsEditActions">
          <button class="btn ghost small" id="docsNewGuideBtn">NEW GUIDE</button>
          <button class="btn ghost small" id="docsNewSectionBtn">NEW SECTION</button>
        </div>
        <div class="docs-actions" id="docsManageActions">
          <label class="pill" id="docsExcludeWrap">
            <input id="docsExcludeToggle" type="checkbox">
            exclude from RAG
          </label>
          <button class="btn danger small" id="docsDeleteGuideBtn">DELETE GUIDE</button>
          <button class="btn danger small" id="docsDeletePageBtn">DELETE PAGE</button>
        </div>

        <label>Guide</label>
        <select id="docsGuideSelect"></select>

        <label>Search docs</label>
        <div class="inline">
          <input id="docsSearchInput" type="text" placeholder="Search across all docsâ€¦" style="flex:1;"/>
          <button class="btn ghost small" id="docsSearchBtn">SEARCH</button>
          <button class="btn ghost small" id="docsSearchClearBtn">CLEAR</button>
        </div>
        <div class="docs-list" id="docsSearchResults" style="display:none; max-height:240px;"></div>

        <label>Pages</label>
        <div class="docs-list" id="docsPageList"></div>

        <div class="tiny muted" id="docsStatus" style="margin-top:10px;"></div>
      </div>

	      <div class="card docs-content">
	        <div class="docs-toolbar">
          <div class="tiny muted" id="docsBreadcrumb">Select a pageâ€¦</div>
          <div class="docs-controls">
            <button class="icon-btn" id="docsNavToggleBtn" title="Toggle sidebar" aria-label="Toggle sidebar">
              <span class="icon icon-collapse" aria-hidden="true">âŸ¨</span>
              <span class="icon icon-expand" aria-hidden="true">âŸ©</span>
            </button>
            <button class="icon-btn" id="docsFullscreenBtn" title="Toggle fullscreen" aria-label="Toggle fullscreen">
              <svg class="icon icon-enter" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 14H5v5h5v-2H7v-3zm0-4h2V7h3V5H5v5zm10 9h-3v2h5v-5h-2v3zm0-14V5h-5v2h3v3h2V5z"/>
              </svg>
	              <svg class="icon icon-exit" viewBox="0 0 24 24" aria-hidden="true">
	                <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
	              </svg>
            </button>
            <button class="icon-btn" id="docsThemeBtn" title="Toggle theme" aria-label="Toggle theme">
	              <svg class="icon icon-sun" viewBox="0 0 24 24" aria-hidden="true">
	                <path d="M6.76 4.84l-1.8-1.79L3.55 4.46l1.79 1.8 1.42-1.42zM1 13h3v-2H1v2zm10 10h2v-3h-2v3zm9-10v-2h3v2h-3zM18.36 6.26l1.79-1.8-1.41-1.41-1.8 1.79 1.42 1.42zM17.24 19.16l1.8 1.79 1.41-1.41-1.79-1.8-1.42 1.42zM4.46 20.95l1.8-1.79-1.42-1.42-1.79 1.8 1.41 1.41zM12 6a6 6 0 100 12 6 6 0 000-12z"/>
	              </svg>
	              <svg class="icon icon-moon" viewBox="0 0 24 24" aria-hidden="true">
	                <path d="M12.74 2a9 9 0 008.26 12.6A8 8 0 1112.74 2z"/>
	              </svg>
            </button>
            <button class="icon-btn" id="docsEditBtn" title="Edit page" aria-label="Edit page">
              <span class="icon-label" aria-hidden="true">âœŽ</span>
            </button>
            <button class="icon-btn" id="docsPdfBtn" title="Download PDF" aria-label="Download PDF">
              <span class="pdf-label" aria-hidden="true">PDF</span>
            </button>
          </div>
        </div>
        <div id="docsPage" class="docsPage"></div>
        <div id="docsEditor" class="docs-editor">
          <details class="docs-cover-editor" id="docsCoverEditor">
            <summary>Cover &amp; Headers</summary>
            <div class="docs-cover-disabled" id="docsCoverDisabled">
              Cover metadata is stored in the first page of this guide.
              <button class="btn ghost small" id="docsCoverGoFirstBtn">OPEN FIRST PAGE</button>
            </div>
            <div class="docs-cover-fields" id="docsCoverFields">
              <label>Guide type</label>
              <input id="docsCoverTypeEdit" type="text" placeholder="Guide"/>
              <label>Guide title</label>
              <input id="docsCoverTitleEdit" type="text" placeholder="Auto title"/>
              <label>Cover image</label>
              <input id="docsCoverImageEdit" type="text" placeholder="/assets/.../image.png"/>
              <label>Cover text</label>
              <textarea id="docsCoverTextEdit" rows="3" placeholder="Optional summary"></textarea>
              <div class="inline">
                <div style="flex:1;">
                  <label>Version override</label>
                  <input id="docsCoverVersionEdit" type="text" placeholder="Auto version"/>
                </div>
                <div style="flex:1;">
                  <label>Date/time override</label>
                  <input id="docsCoverDateEdit" type="text" placeholder="Auto date/time"/>
                </div>
              </div>
              <label>Copyright</label>
              <input id="docsCoverCopyrightEdit" type="text" placeholder="Â© Luxriot"/>
              <div class="inline">
                <div style="flex:1;">
                  <label>Header left override</label>
                  <input id="docsHeaderLeftEdit" type="text" placeholder="Auto (guide type)"/>
                </div>
                <div style="flex:1;">
                  <label>Header right override</label>
                  <input id="docsHeaderRightEdit" type="text" placeholder="Auto (section heading)"/>
                </div>
              </div>
              <div class="inline" style="margin-top:8px;">
                <button class="btn ghost small" id="docsCoverResetBtn">USE DEFAULTS</button>
              </div>
            </div>
            <div class="docs-cover-preview" id="docsCoverPreview">
              <div class="cover-type" id="docsCoverPreviewType"></div>
              <div class="cover-title" id="docsCoverPreviewTitle"></div>
              <div class="cover-image" id="docsCoverPreviewImage"></div>
              <div class="cover-text" id="docsCoverPreviewText"></div>
              <div class="cover-footer" id="docsCoverPreviewFooter"></div>
            </div>
          </details>
          <div class="docs-edit-tools">
            <div class="tiny muted" id="docsEditMeta">Edit mode</div>
            <button class="btn ghost small" data-insert="h1">H1</button>
            <button class="btn ghost small" data-insert="h2">H2</button>
            <button class="btn ghost small" data-insert="h3">H3</button>
            <button class="btn ghost small" data-insert="h4">H4</button>
            <button class="btn ghost small" data-insert="h5">H5</button>
            <button class="btn ghost small" data-insert="ul">List</button>
            <button class="btn ghost small" data-insert="ol">Steps</button>
            <button class="btn ghost small" data-insert="table">Table</button>
            <button class="btn ghost small" data-insert="tip">Tip</button>
            <button class="btn ghost small" data-insert="warn">Warning</button>
            <button class="btn ghost small" data-insert="info">Info</button>
            <button class="btn ghost small" id="docsInsertLinkBtn">Link</button>
            <button class="btn ghost small" id="docsInsertImageBtn">Image</button>
            <button class="btn ghost small" id="docsScrollLockBtn">LOCK SCROLL</button>
            <input id="docsImageInput" type="file" accept="image/*" style="display:none;">
          </div>
          <div class="docs-edit-body">
            <textarea id="docsEditText" class="docs-edit-text mono" placeholder="Edit markdown..."></textarea>
            <div id="docsEditPreview" class="docs-edit-preview"></div>
          </div>
          <div class="docs-edit-actions">
            <div class="docs-edit-status" id="docsEditStatus">Draft: none Â· Published: none</div>
            <div class="inline">
              <button class="btn ghost small" id="docsEditResetBaseBtn">RESET TO BASE</button>
              <button class="btn ghost small" id="docsEditResetPublishedBtn">RESET TO PUBLISHED</button>
              <button class="btn ghost small" id="docsEditDiscardBtn">DISCARD DRAFT</button>
              <button class="btn small" id="docsEditSaveDraftBtn">SAVE DRAFT</button>
              <button class="btn small" id="docsEditRequestPublishBtn">REQUEST PUBLISH</button>
              <button class="btn primary small" id="docsEditPublishBtn">PUBLISH</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="admin-actions">
      <button class="btn primary" id="docsOkBtn">OK</button>
    </div>
  </div>

  <!-- NEW: Retrieval debug panel -->
  <div id="debugPanel" class="modal" role="dialog" aria-label="Retrieval debug">
    <div class="modal-header">Retrieval debug:</div>

    <div class="debug-body">
      <div class="debug-grid">
        <div class="card">
          <h3>Query</h3>
          <label>Query</label>
          <textarea id="debugQuery" class="mono" style="height:120px;" placeholder="Type a question, then RUN."></textarea>

          <div class="inline" style="margin-top:10px;">
            <div style="flex:1;">
              <label>k</label>
              <input id="debugK" type="number" min="1" max="25" value="8"/>
            </div>
            <div style="flex:1;">
              <label>&nbsp;</label>
              <button class="btn small" id="debugRunBtn">RUN</button>
            </div>
          </div>

          <div class="tiny muted" id="debugStatus" style="margin-top:10px;"></div>

          <details class="err-details" style="margin-top:10px;">
            <summary>Show settings snapshot</summary>
            <pre id="debugSettings"></pre>
          </details>
        </div>

        <div class="card">
          <h3>Selected chunks (why)</h3>
          <div id="debugResults" class="debug-results"></div>
          <details class="err-details" style="margin-top:10px;">
            <summary>Show raw JSON</summary>
            <pre id="debugRaw"></pre>
          </details>
        </div>
      </div>
    </div>

    <div class="admin-actions">
      <button class="btn ghost" id="debugUseLastBtn">USE LAST</button>
      <button class="btn primary" id="debugOkBtn">OK</button>
    </div>
  </div>

	  <!-- User settings / login panel -->
		  <div id="userSettings" class="user-settings">
		    <div class="title">User</div>
		    <div class="row2"><span class="slash">/</span> Status: <span class="kbd" id="authStatus">â€”</span></div>
		    <div class="row2"><span class="slash">/</span> Role: <span class="kbd" id="authRole">â€”</span></div>
		    <div class="row2"><span class="slash">/</span> Email: <span class="kbd" id="authEmail">â€”</span></div>

		    <div id="loginForm" style="margin-top:10px;">
		      <label style="margin-top:10px;">Username or email</label>
		      <input id="loginUsername" type="text" placeholder="admin / name@example.com"/>
		      <label>Password</label>
		      <input id="loginPassword" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"/>
		      <div class="inline" style="margin-top:10px;justify-content:space-between;">
		        <button class="btn primary small" id="loginBtn">LOGIN</button>
		        <button class="btn ghost small" id="logoutBtn" style="display:none;">LOGOUT</button>
		      </div>
		      <div class="tiny muted" id="authHint" style="margin-top:10px;"></div>
		    </div>
		
		    <div id="pwChangeForm" style="margin-top:12px;display:none;">
		      <div class="hr"></div>
		      <div class="tiny muted">Change password</div>
		      <label style="margin-top:10px;">Current password</label>
		      <input id="pwCurrent" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"/>
		      <label>New password</label>
		      <input id="pwNew" type="password" placeholder="min 6 chars"/>
		      <div class="inline" style="margin-top:10px;justify-content:space-between;">
		        <button class="btn ghost small" id="pwChangeBtn">CHANGE</button>
		      </div>
		      <div class="tiny muted" id="pwChangeHint" style="margin-top:10px;"></div>
		    </div>
		  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-container@3.0.0/dist/markdown-it-container.min.js"></script>
<script>
  // Mobile viewport height fix (fallback for browsers without dvh).
  function setVhUnit(){
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  setVhUnit();
  window.addEventListener('resize', setVhUnit);

  // ---------- Backend wiring ----------
  const apiParam = new URLSearchParams(location.search).get('api');
  const defaultApiBase = (location.protocol === 'file:' ? 'http://localhost:8000' : location.origin);
  const apiBase = (apiParam || defaultApiBase).replace(/\/$/, '');

  // "conversation" state (also used by the redactor UI)
  const session = {
    session_id: null,
    model: { id: "LM Studio", temp: 0.2, top_k: 50, top_p: 0.85 },
    tool_context: { mcp_internet: false, mcp_luxriot_docs: true }
  };

  let lastUserMessage = "User input";
  let lastAssistantMessage = "Hi Sasha, I am ready to assist and learn.";
  let lastRetrievalPack = null; // last /docs/search response (may include debug)
  let activeChatAbort = null;

  const annotations = []; // in-memory only

  const DOCS_FONT_PRESETS = [
    {
      key: 'sans',
      label: 'Neutral Sans',
      css: '"IBM Plex Sans","Source Sans 3","Segoe UI",system-ui,sans-serif'
    },
    {
      key: 'titillium',
      label: 'Titillium Web',
      css: '"Titillium Web","Source Sans 3","Segoe UI",system-ui,sans-serif'
    },
    {
      key: 'grotesk',
      label: 'Grotesk',
      css: '"Space Grotesk","Work Sans","Segoe UI",system-ui,sans-serif'
    },
    {
      key: 'serif',
      label: 'Editorial Serif',
      css: '"IBM Plex Serif","Source Serif 4","Georgia",serif'
    },
    {
      key: 'slab',
      label: 'Slab Serif',
      css: '"Bitter","Rockwell","Georgia",serif'
    },
    {
      key: 'mono',
      label: 'Monospace',
      css: '"JetBrains Mono","Fira Code",ui-monospace,Menlo,monospace'
    }
  ];
  const DOCS_FONT_PRESET_MAP = DOCS_FONT_PRESETS.reduce((acc, item) => {
    acc[item.key] = item;
    return acc;
  }, {});
  let docsStyleState = {
    heading_font: 'sans',
    body_font: 'sans',
    cover_type: 'Guide',
    cover_image: '',
    cover_text: '',
    cover_copyright: ''
  };

  // ---------- UI handles ----------
  const historyPanel = document.getElementById('historyPanel');
  const historyList = document.getElementById('historyList');
  const overlay = document.getElementById('overlay');

  const thread = document.getElementById('thread');
  const emptyState = document.getElementById('emptyState');

  const adminPanel = document.getElementById('adminPanel');
  const redactorPanel = document.getElementById('redactorPanel');
  const docsPanel = document.getElementById('docsPanel');
  const debugPanel = document.getElementById('debugPanel');

  const toolsBtn = document.getElementById('toolsBtn');
  const topToolToggle = document.getElementById('topToolToggle');
  const docsBtn = document.getElementById('docsBtn');
  const debugBtn = document.getElementById('debugBtn');
  const redactorBtn = document.getElementById('redactorBtn');
  const historyBtn = document.getElementById('historyBtn');

		  const userToggle = document.getElementById('userToggle');
		  const userSettings = document.getElementById('userSettings');
		  const authStatusEl = document.getElementById('authStatus');
		  const authRoleEl = document.getElementById('authRole');
		  const authEmailEl = document.getElementById('authEmail');
		  const authHintEl = document.getElementById('authHint');
		  const loginFormEl = document.getElementById('loginForm');
		  const loginUsernameEl = document.getElementById('loginUsername');
		  const loginPasswordEl = document.getElementById('loginPassword');
		  const loginBtnEl = document.getElementById('loginBtn');
		  const logoutBtnEl = document.getElementById('logoutBtn');
		  const pwChangeFormEl = document.getElementById('pwChangeForm');
		  const pwCurrentEl = document.getElementById('pwCurrent');
		  const pwNewEl = document.getElementById('pwNew');
		  const pwChangeBtnEl = document.getElementById('pwChangeBtn');
		  const pwChangeHintEl = document.getElementById('pwChangeHint');

  // Redactor fields
  const scoreEl = document.getElementById('score');
  const rightEl = document.getElementById('right');
  const wrongEl = document.getElementById('wrong');
  const goldenEl = document.getElementById('golden');
  const confidenceEl = document.getElementById('confidence');
  const confValEl = document.getElementById('confVal');
  const includeContextEl = document.getElementById('includeContext');

  const saveBtn = document.getElementById('saveAnnotationBtn');
  const saveHint = document.getElementById('saveHint');

  const annoList = document.getElementById('annoList');
  const filterTag = document.getElementById('filterTag');
  const sortBy = document.getElementById('sortBy');

		  const userInput = document.getElementById('userInput');
		  const sendBtn = document.getElementById('sendBtn');

		  // ---------- Responsive dock layout ----------
		  const dockEl = document.getElementById('dock');
		  const dockActionsEl = dockEl ? dockEl.querySelector('.actions-left') : null;

		  let dockUpdateScheduled = false;
		  function scheduleDockUpdate() {
		    if (!dockEl) return;
		    if (dockUpdateScheduled) return;
		    dockUpdateScheduled = true;
		    requestAnimationFrame(() => {
		      dockUpdateScheduled = false;
		      updateDockLayout();
		      updateDockInsets();
		    });
		  }

		  function updateDockInsets() {
		    if (!dockEl) return;
		    const rect = dockEl.getBoundingClientRect();
		    const inset = Math.max(0, window.innerHeight - rect.top);
		    document.documentElement.style.setProperty('--dock-inset', `${inset}px`);
		  }

			  function updateDockLayout() {
			    if (!dockEl || !dockActionsEl || !userInput) return;
			    const IDEAL_INPUT_PX = 520;
			    const SMALL_INPUT_PX = 420;
			    const MIN_INPUT_PX = 340;

			    dockEl.classList.remove('state-actions-wrap', 'state-input-small', 'state-stack');

				    const allActionButtons = Array.from(dockActionsEl.querySelectorAll('.action'));
				    const actionButtons = allActionButtons.filter((el) => getComputedStyle(el).display !== 'none');
				    const actionCount = actionButtons.length;
				    const actionW = actionButtons.find((el) => getComputedStyle(el).display !== 'none')?.getBoundingClientRect().width || 46;
				    const gap = parseFloat(getComputedStyle(dockActionsEl).gap || '14') || 14;
				    const perRow = Math.max(1, Math.ceil(actionCount / 2));
				    const wrapW = Math.round(perRow * actionW + Math.max(0, perRow - 1) * gap);
				    dockEl.style.setProperty('--dock-actions-wrap-w', `${wrapW}px`);

			    const inputW = () => userInput.getBoundingClientRect().width;

			    // State 1: one-row actions + wide input.
			    if (inputW() >= IDEAL_INPUT_PX) return;

			    // State 2: wrap actions into 2 rows first.
			    dockEl.classList.add('state-actions-wrap');
			    if (inputW() >= IDEAL_INPUT_PX) return;

			    // State 3: allow input to shrink to ~300â€“400px range (tighter spacing).
			    if (inputW() >= SMALL_INPUT_PX) return;
			    dockEl.classList.add('state-input-small');
			    if (inputW() >= MIN_INPUT_PX) return;

			    // State 4: stack actions under the prompt (single line).
			    dockEl.classList.remove('state-actions-wrap', 'state-input-small');
			    dockEl.classList.add('state-stack');
			  }

		  if (dockEl && 'ResizeObserver' in window) {
		    const ro = new ResizeObserver(() => scheduleDockUpdate());
		    ro.observe(dockEl);
		  }
		  window.addEventListener('resize', () => scheduleDockUpdate());
		  scheduleDockUpdate();

	  function resolveDocsFontCss(key) {
	    if (!key) return '';
	    const preset = DOCS_FONT_PRESET_MAP[key];
	    if (preset && preset.css) return preset.css;
	    return String(key);
	  }

	  function populateDocsFontSelect(selectEl, selectedKey) {
	    if (!selectEl) return;
	    selectEl.innerHTML = '';
	    DOCS_FONT_PRESETS.forEach((preset) => {
	      const opt = document.createElement('option');
	      opt.value = preset.key;
	      opt.textContent = preset.label;
	      selectEl.appendChild(opt);
	    });
	    if (selectedKey && DOCS_FONT_PRESET_MAP[selectedKey]) {
	      selectEl.value = selectedKey;
	    } else if (selectEl.options.length) {
	      selectEl.selectedIndex = 0;
	    }
	  }

  function applyDocsStyle(style) {
    const headingKey = String(style?.heading_font || docsStyleState.heading_font || 'sans');
    const bodyKey = String(style?.body_font || docsStyleState.body_font || 'sans');
    const coverType = String(style?.cover_type ?? docsStyleState.cover_type ?? 'Guide');
    const coverImage = String(style?.cover_image ?? docsStyleState.cover_image ?? '');
    const coverText = String(style?.cover_text ?? docsStyleState.cover_text ?? '');
    const coverCopyright = String(style?.cover_copyright ?? docsStyleState.cover_copyright ?? '');
    docsStyleState = {
      heading_font: headingKey,
      body_font: bodyKey,
      cover_type: coverType,
      cover_image: coverImage,
      cover_text: coverText,
      cover_copyright: coverCopyright
    };
    const headingCss = resolveDocsFontCss(headingKey);
    const bodyCss = resolveDocsFontCss(bodyKey);
    if (headingCss) document.documentElement.style.setProperty('--docs-heading-font', headingCss);
    if (bodyCss) document.documentElement.style.setProperty('--docs-body-font', bodyCss);
    populateDocsFontSelect(docsHeadingFontEl, headingKey);
    populateDocsFontSelect(docsBodyFontEl, bodyKey);
    if (docsCoverTypeEl) docsCoverTypeEl.value = coverType || '';
    if (docsCoverImageEl) docsCoverImageEl.value = coverImage || '';
    if (docsCoverTextEl) docsCoverTextEl.value = coverText || '';
    if (docsCoverCopyrightEl) docsCoverCopyrightEl.value = coverCopyright || '';
    if (docsState.editing) applyCoverEditorState();
  }

	  async function loadDocsStyle() {
	    try {
	      const res = await apiJson('/docs/style');
	      applyDocsStyle(res || {});
	    } catch (e) {
	      applyDocsStyle({});
	    }
	  }

  async function saveDocsStyle() {
    if (!docsHeadingFontEl || !docsBodyFontEl) return;
    const payload = {
      heading_font: String(docsHeadingFontEl.value || '').trim(),
      body_font: String(docsBodyFontEl.value || '').trim(),
      cover_type: String(docsCoverTypeEl?.value || '').trim(),
      cover_image: String(docsCoverImageEl?.value || '').trim(),
      cover_text: String(docsCoverTextEl?.value || '').trim(),
      cover_copyright: String(docsCoverCopyrightEl?.value || '').trim()
    };
    applyDocsStyle(payload);
	    try {
	      await apiJson('/docs/style', { method: 'POST', body: payload });
	      if (docsStatusEl) docsStatusEl.textContent = 'Docs font updated.';
	    } catch (e) {
	      const raw = e?.raw ? String(e.raw) : String(e);
	      if (docsStatusEl) docsStatusEl.textContent = `Font update failed: ${raw}`;
	    }
	  }

	  // ---------- Admin settings UI ----------
	  const appVersionEl = document.getElementById('appVersion');
	  const adminApiBaseEl = document.getElementById('adminApiBase');
	  const adminDocsVersionEl = document.getElementById('adminDocsVersion');
		  const adminDatastoreReadyEl = document.getElementById('adminDatastoreReady');
		  const adminLmstudioUrlEl = document.getElementById('adminLmstudioUrl');

		  const adminPromptRoleEl = document.getElementById('adminPromptRole');
		  const adminSystemPromptEl = document.getElementById('adminSystemPrompt');
		  const adminPromptPreviewEl = document.getElementById('adminPromptPreview');
		  const adminSaveHintEl = document.getElementById('adminSaveHint');

		  const adminRetrievalModeEl = document.getElementById('adminRetrievalMode');
		  const adminRetrievalKEl = document.getElementById('adminRetrievalK');
		  const adminMaxCitationsEl = document.getElementById('adminMaxCitations');
		  const adminMaxImagesEl = document.getElementById('adminMaxImages');
		  const adminDocPriorityBoostEl = document.getElementById('adminDocPriorityBoost');
		  const adminHeadingBoostEl = document.getElementById('adminHeadingBoost');
		  const adminDocPriorityEl = document.getElementById('adminDocPriority');
		  const adminMaxPerPageEl = document.getElementById('adminMaxPerPage');
		  const adminMaxPerDocEl = document.getElementById('adminMaxPerDoc');
		  const adminRrfKEl = document.getElementById('adminRrfK');
		  const adminBm25WeightEl = document.getElementById('adminBm25Weight');
		  const adminEmbWeightEl = document.getElementById('adminEmbWeight');
		  const adminBm25CandidatesEl = document.getElementById('adminBm25Candidates');
		  const adminEmbCandidatesEl = document.getElementById('adminEmbCandidates');
		  const adminSummaryEnabledEl = document.getElementById('adminSummaryEnabled');
		  const adminSummaryModelEl = document.getElementById('adminSummaryModel');
		  const adminSummaryKEl = document.getElementById('adminSummaryK');
		  const adminSummaryMaxPagesEl = document.getElementById('adminSummaryMaxPages');
		  const adminSummaryUnitTokensEl = document.getElementById('adminSummaryUnitTokens');
		  const adminSummaryMaxCharsEl = document.getElementById('adminSummaryMaxChars');
		  const adminSummaryMaxTokensEl = document.getElementById('adminSummaryMaxTokens');
		  const adminMmrEnabledEl = document.getElementById('adminMmrEnabled');
		  const adminMmrUseEmbeddingsEl = document.getElementById('adminMmrUseEmbeddings');
		  const adminMmrLambdaEl = document.getElementById('adminMmrLambda');
		  const adminMmrCandidatesEl = document.getElementById('adminMmrCandidates');
		  const adminExpandNeighborsEl = document.getElementById('adminExpandNeighbors');
		  const adminExpandMaxCharsEl = document.getElementById('adminExpandMaxChars');
		  const adminExpandIncludeImagesEl = document.getElementById('adminExpandIncludeImages');
		  const adminToolCallsEnabledEl = document.getElementById('adminToolCallsEnabled');
		  const adminToolCallsMaxEl = document.getElementById('adminToolCallsMax');

		  const adminModelIdEl = document.getElementById('adminModelId');
		  const adminTimeoutSEl = document.getElementById('adminTimeoutS');
		  const adminTemperatureEl = document.getElementById('adminTemperature');
	  const adminMaxTokensEl = document.getElementById('adminMaxTokens');

	  const adminDocsDirEl = document.getElementById('adminDocsDir');
	  const adminIngestEmbeddingsEl = document.getElementById('adminIngestEmbeddings');
	  const adminIncludeEditsEl = document.getElementById('adminIncludeEdits');
	  const adminEmbeddingMaxCharsEl = document.getElementById('adminEmbeddingMaxChars');
	  const adminEmbeddingBatchSizeEl = document.getElementById('adminEmbeddingBatchSize');
	  const adminReindexBtnEl = document.getElementById('adminReindexBtn');
	  const adminReindexRefreshBtnEl = document.getElementById('adminReindexRefreshBtn');
	  const adminReindexStatusEl = document.getElementById('adminReindexStatus');
	  const adminReindexLogsEl = document.getElementById('adminReindexLogs');
	  const adminPublishRefreshBtnEl = document.getElementById('adminPublishRefreshBtn');
	  const adminPublishStatusEl = document.getElementById('adminPublishStatus');
	  const adminPublishListEl = document.getElementById('adminPublishList');

		  const adminWebEnabledEl = document.getElementById('adminWebEnabled');
		  const adminWebTimeoutSEl = document.getElementById('adminWebTimeoutS');
		  const adminWebMaxCharsEl = document.getElementById('adminWebMaxChars');
		  const adminWebMaxBytesEl = document.getElementById('adminWebMaxBytes');
		  const adminWebMaxUrlsEl = document.getElementById('adminWebMaxUrls');
		  const adminWebSearchKEl = document.getElementById('adminWebSearchK');

			  // Admin: users
			  const adminNewUserUsernameEl = document.getElementById('adminNewUserUsername');
			  const adminNewUserRoleEl = document.getElementById('adminNewUserRole');
			  const adminNewUserEmailEl = document.getElementById('adminNewUserEmail');
			  const adminNewUserPasswordEl = document.getElementById('adminNewUserPassword');
			  const adminNewUserGreetingEl = document.getElementById('adminNewUserGreeting');
			  const adminUsersRefreshBtnEl = document.getElementById('adminUsersRefreshBtn');
			  const adminUsersCreateBtnEl = document.getElementById('adminUsersCreateBtn');
			  const adminUsersStatusEl = document.getElementById('adminUsersStatus');
			  const adminUsersListEl = document.getElementById('adminUsersList');
			  const adminUserEditDetailsEl = document.getElementById('adminUserEditDetails');
		  const adminEditUserUsernameEl = document.getElementById('adminEditUserUsername');
		  const adminEditUserEmailEl = document.getElementById('adminEditUserEmail');
		  const adminEditUserRoleEl = document.getElementById('adminEditUserRole');
		  const adminEditUserDocsEditEl = document.getElementById('adminEditUserDocsEdit');
		  const adminEditUserDocsPublishEl = document.getElementById('adminEditUserDocsPublish');
		  const adminEditUserDisabledEl = document.getElementById('adminEditUserDisabled');
		  const adminEditUserGreetingEl = document.getElementById('adminEditUserGreeting');
			  const adminEditUserPasswordEl = document.getElementById('adminEditUserPassword');
			  const adminEditUserSaveBtnEl = document.getElementById('adminEditUserSaveBtn');
			  const adminEditUserClearBtnEl = document.getElementById('adminEditUserClearBtn');
			  const adminEditUserStatusEl = document.getElementById('adminEditUserStatus');

    // ---------- Docs reader UI ----------
    const docsVersionSelectEl = document.getElementById('docsVersionSelect');
    const docsGuideSelectEl = document.getElementById('docsGuideSelect');
    const docsEditActionsEl = document.getElementById('docsEditActions');
    const docsStyleCardEl = document.getElementById('docsStyleCard');
    const docsHeadingFontEl = document.getElementById('docsHeadingFont');
    const docsBodyFontEl = document.getElementById('docsBodyFont');
    const docsCoverTypeEl = document.getElementById('docsCoverType');
    const docsCoverImageEl = document.getElementById('docsCoverImage');
    const docsCoverTextEl = document.getElementById('docsCoverText');
    const docsCoverCopyrightEl = document.getElementById('docsCoverCopyright');
    const docsNewGuideBtn = document.getElementById('docsNewGuideBtn');
    const docsNewSectionBtn = document.getElementById('docsNewSectionBtn');
    const docsManageActionsEl = document.getElementById('docsManageActions');
    const docsExcludeWrapEl = document.getElementById('docsExcludeWrap');
    const docsExcludeToggleEl = document.getElementById('docsExcludeToggle');
    const docsDeleteGuideBtn = document.getElementById('docsDeleteGuideBtn');
    const docsDeletePageBtn = document.getElementById('docsDeletePageBtn');
    const docsSearchInputEl = document.getElementById('docsSearchInput');
    const docsSearchBtn = document.getElementById('docsSearchBtn');
    const docsSearchClearBtn = document.getElementById('docsSearchClearBtn');
    const docsSearchResultsEl = document.getElementById('docsSearchResults');
    const docsPageListEl = document.getElementById('docsPageList');
    const docsPageEl = document.getElementById('docsPage');
    const docsBreadcrumbEl = document.getElementById('docsBreadcrumb');
    const docsStatusEl = document.getElementById('docsStatus');
    const docsNavToggleBtn = document.getElementById('docsNavToggleBtn');
    const docsFullscreenBtn = document.getElementById('docsFullscreenBtn');
    const docsThemeBtn = document.getElementById('docsThemeBtn');
    const docsEditBtn = document.getElementById('docsEditBtn');
    const docsPdfBtn = document.getElementById('docsPdfBtn');
    const docsEditorEl = document.getElementById('docsEditor');
    const docsEditTextEl = document.getElementById('docsEditText');
    const docsEditPreviewEl = document.getElementById('docsEditPreview');
    const docsEditMetaEl = document.getElementById('docsEditMeta');
    const docsCoverEditorEl = document.getElementById('docsCoverEditor');
    const docsCoverDisabledEl = document.getElementById('docsCoverDisabled');
    const docsCoverFieldsEl = document.getElementById('docsCoverFields');
    const docsCoverGoFirstBtn = document.getElementById('docsCoverGoFirstBtn');
    const docsCoverTypeEditEl = document.getElementById('docsCoverTypeEdit');
    const docsCoverTitleEditEl = document.getElementById('docsCoverTitleEdit');
    const docsCoverImageEditEl = document.getElementById('docsCoverImageEdit');
    const docsCoverTextEditEl = document.getElementById('docsCoverTextEdit');
    const docsCoverVersionEditEl = document.getElementById('docsCoverVersionEdit');
    const docsCoverDateEditEl = document.getElementById('docsCoverDateEdit');
    const docsCoverCopyrightEditEl = document.getElementById('docsCoverCopyrightEdit');
    const docsHeaderLeftEditEl = document.getElementById('docsHeaderLeftEdit');
    const docsHeaderRightEditEl = document.getElementById('docsHeaderRightEdit');
    const docsCoverPreviewEl = document.getElementById('docsCoverPreview');
    const docsCoverPreviewTypeEl = document.getElementById('docsCoverPreviewType');
    const docsCoverPreviewTitleEl = document.getElementById('docsCoverPreviewTitle');
    const docsCoverPreviewImageEl = document.getElementById('docsCoverPreviewImage');
    const docsCoverPreviewTextEl = document.getElementById('docsCoverPreviewText');
    const docsCoverPreviewFooterEl = document.getElementById('docsCoverPreviewFooter');
    const docsCoverResetBtn = document.getElementById('docsCoverResetBtn');
    const docsEditStatusEl = document.getElementById('docsEditStatus');
    const docsEditSaveDraftBtn = document.getElementById('docsEditSaveDraftBtn');
    const docsEditRequestPublishBtn = document.getElementById('docsEditRequestPublishBtn');
    const docsEditPublishBtn = document.getElementById('docsEditPublishBtn');
    const docsEditDiscardBtn = document.getElementById('docsEditDiscardBtn');
    const docsEditResetBaseBtn = document.getElementById('docsEditResetBaseBtn');
    const docsEditResetPublishedBtn = document.getElementById('docsEditResetPublishedBtn');
    const docsInsertLinkBtn = document.getElementById('docsInsertLinkBtn');
    const docsInsertImageBtn = document.getElementById('docsInsertImageBtn');
    const docsImageInputEl = document.getElementById('docsImageInput');
    const docsScrollLockBtn = document.getElementById('docsScrollLockBtn');
    const docsOkBtn = document.getElementById('docsOkBtn');
    const docsContentEl = document.querySelector('#docsPanel .docs-content');

    // ---------- Retrieval debug UI ----------
    const debugQueryEl = document.getElementById('debugQuery');
    const debugKEl = document.getElementById('debugK');
    const debugRunBtn = document.getElementById('debugRunBtn');
    const debugUseLastBtn = document.getElementById('debugUseLastBtn');
    const debugOkBtn = document.getElementById('debugOkBtn');
    const debugStatusEl = document.getElementById('debugStatus');
    const debugSettingsEl = document.getElementById('debugSettings');
    const debugResultsEl = document.getElementById('debugResults');
    const debugRawEl = document.getElementById('debugRaw');

			  let adminBundle = null; // {defaults, settings, effective}
			  const PROMPT_ROLES = ['admin', 'redactor', 'support', 'client', 'anonymous'];
			  let adminPromptTemplates = {};
			  let adminActivePromptRole = 'admin';
			  let adminUsersCache = [];
			  let adminSelectedUserId = null;
			  let adminSelectedUserDisabled = false;
			  let chatKDefault = 8;
		  let reindexPollTimer = null;
		  let lastReindex = null;

	  function _linesToList(text) {
	    return String(text || '')
	      .split('\n')
	      .map((x) => x.trim())
	      .filter((x) => x.length);
	  }

		  function _renderPreview(template) {
		    const retrievalMode = adminRetrievalModeEl.value || 'bm25';
		    const retrievalK = adminRetrievalKEl.value || String(chatKDefault);
		    const docPriority = _linesToList(adminDocPriorityEl.value).join(', ');
		    const webEnabled = adminWebEnabledEl ? Boolean(adminWebEnabledEl.checked) : false;
		    const vars = {
		      user_role: adminActivePromptRole,
		      username: (authState && authState.username) ? String(authState.username) : '(user)',
		      docs_version: adminDocsVersionEl.textContent || '(unknown)',
		      retrieval_mode: retrievalMode,
		      retrieval_k: retrievalK,
		      doc_priority: docPriority,
	      web_enabled: String(webEnabled),
	      web_context: '(external web context inserted at runtime)',
	      context: '(documentation context inserted at runtime)'
	    };
	    let out = String(template || '');
	    Object.entries(vars).forEach(([k, v]) => {
	      out = out.split(`{{${k}}}`).join(String(v));
	    });
	    return out;
	  }

		  function _syncPromptPreview() {
		    if (!adminPromptPreviewEl) return;
		    adminPromptPreviewEl.textContent = _renderPreview(adminSystemPromptEl?.value || '');
		  }

		  function _setPromptRole(role, { preserveCurrent = true } = {}) {
		    const next = String(role || '').trim();
		    const r = PROMPT_ROLES.includes(next) ? next : 'client';
		    if (preserveCurrent && adminSystemPromptEl && adminActivePromptRole) {
		      adminPromptTemplates[adminActivePromptRole] = String(adminSystemPromptEl.value || '');
		    }
		    adminActivePromptRole = r;
		    if (adminPromptRoleEl) adminPromptRoleEl.value = r;
		    if (adminSystemPromptEl) adminSystemPromptEl.value = String(adminPromptTemplates[r] ?? '');
		    _syncPromptPreview();
		  }

		  function _loadPromptTemplates(source) {
		    const effective = source || {};
		    const base = typeof effective.system_prompt_template === 'string' ? effective.system_prompt_template : '';
		    const raw = effective.system_prompt_templates;
		    const out = {};
		    if (raw && typeof raw === 'object') {
		      PROMPT_ROLES.forEach((r) => {
		        if (Object.prototype.hasOwnProperty.call(raw, r)) {
		          out[r] = (typeof raw[r] === 'string') ? raw[r] : '';
		        } else {
		          out[r] = base;
		        }
		      });
		    } else {
		      PROMPT_ROLES.forEach((r) => { out[r] = base; });
		    }
		    adminPromptTemplates = out;
		  }

		  adminPromptRoleEl?.addEventListener('change', () => _setPromptRole(adminPromptRoleEl.value));
		  adminSystemPromptEl?.addEventListener('input', () => {
		    if (adminActivePromptRole) adminPromptTemplates[adminActivePromptRole] = String(adminSystemPromptEl.value || '');
		    _syncPromptPreview();
		  });
		  adminRetrievalModeEl.addEventListener('change', _syncPromptPreview);
		  adminRetrievalKEl.addEventListener('input', _syncPromptPreview);
		  adminDocPriorityEl.addEventListener('input', _syncPromptPreview);

	  function stopReindexPoll() {
	    if (reindexPollTimer) {
	      clearInterval(reindexPollTimer);
	      reindexPollTimer = null;
	    }
	  }

	  function _fmtJob(job) {
	    if (!job) return 'Idle.';
	    const st = String(job.status || 'unknown');
	    const phase = String(job.phase || 'unknown');
	    const done = typeof job.doc_done === 'number' ? job.doc_done : null;
	    const total = typeof job.doc_total === 'number' ? job.doc_total : null;
	    const prog = (done !== null && total !== null) ? ` ${done}/${total} docs` : '';
	    const code = (typeof job.exit_code === 'number') ? ` exit=${job.exit_code}` : '';
	    return `${st} Â· ${phase}${prog}${code}`;
	  }

	  function renderReindexStatus(payload) {
	    lastReindex = payload || null;
	    const defaults = payload?.defaults || {};
	    const job = payload?.job || null;

	    if (adminDocsDirEl && (!adminDocsDirEl.value || adminDocsDirEl.value.trim().length < 2)) {
	      adminDocsDirEl.value = String(defaults.docs_dir || 'docs');
	    }
	    if (adminEmbeddingMaxCharsEl && !adminEmbeddingMaxCharsEl.value) {
	      adminEmbeddingMaxCharsEl.value = String(job?.embedding_max_chars ?? defaults.embedding_max_chars ?? 448);
	    }
	    if (adminEmbeddingBatchSizeEl && !adminEmbeddingBatchSizeEl.value) {
	      adminEmbeddingBatchSizeEl.value = String(job?.embedding_batch_size ?? defaults.embedding_batch_size ?? 8);
	    }
	    if (adminIncludeEditsEl) {
	      adminIncludeEditsEl.checked = Boolean(job?.include_edits ?? defaults.include_edits ?? true);
	    }

	    if (adminReindexStatusEl) {
	      adminReindexStatusEl.textContent = _fmtJob(job);
	    }
	    if (adminReindexLogsEl) {
	      const lines = Array.isArray(job?.logs_tail) ? job.logs_tail : [];
	      adminReindexLogsEl.textContent = lines.join('\n');
	    }

	    const running = job?.status === 'running';
	    if (adminReindexBtnEl) adminReindexBtnEl.disabled = Boolean(running);
	    if (adminReindexRefreshBtnEl) adminReindexRefreshBtnEl.disabled = Boolean(running);
	  }

	  async function fetchReindexStatus({ startPoll = true } = {}) {
	    try {
	      const payload = await apiJson('/admin/reindex');
	      renderReindexStatus(payload);
	      const running = payload?.job?.status === 'running';
	      if (running && startPoll && !reindexPollTimer) {
	        reindexPollTimer = setInterval(() => fetchReindexStatus({ startPoll: false }), 1200);
	      }
	      if (!running) stopReindexPoll();
	      return payload;
	    } catch (e) {
	      if (adminReindexStatusEl) adminReindexStatusEl.textContent = `Reindex status failed: ${e?.raw ? String(e.raw) : String(e)}`;
	      stopReindexPoll();
	      return null;
	    }
	  }

	  async function startReindex() {
	    const docsDir = String(adminDocsDirEl?.value || '').trim();
	    const computeEmb = Boolean(adminIngestEmbeddingsEl?.checked);
	    const embMax = Number(adminEmbeddingMaxCharsEl?.value || 448);
	    const embBatch = Number(adminEmbeddingBatchSizeEl?.value || 8);
	    const includeEdits = Boolean(adminIncludeEditsEl?.checked);

	    if (!docsDir) {
	      if (adminReindexStatusEl) adminReindexStatusEl.textContent = 'Set docs folder path first.';
	      return;
	    }
	    if (!confirm(`Re-index docs from:\\n${docsDir}\\n\\nThis rebuilds the datastore and may take a while.`)) return;

	    if (adminReindexStatusEl) adminReindexStatusEl.textContent = 'Starting reindex...';
	    try {
	      const payload = await apiJson('/admin/reindex', {
	        method: 'POST',
	        body: {
	          docs_dir: docsDir,
	          compute_embeddings: computeEmb,
	          embedding_max_chars: embMax,
	          embedding_batch_size: embBatch,
	          include_edits: includeEdits,
	        }
	      });
	      renderReindexStatus(payload);
	      fetchReindexStatus().catch(() => {});
	    } catch (e) {
	      if (adminReindexStatusEl) adminReindexStatusEl.textContent = `Reindex start failed: ${e?.raw ? String(e.raw) : String(e)}`;
	    }
	  }

	  async function startRefresh() {
	    const computeEmb = Boolean(adminIngestEmbeddingsEl?.checked);
	    const embMax = Number(adminEmbeddingMaxCharsEl?.value || 448);
	    const embBatch = Number(adminEmbeddingBatchSizeEl?.value || 8);
	    const includeEdits = Boolean(adminIncludeEditsEl?.checked);

	    if (!confirm('Refresh index from existing datastore? This keeps current Markdown and rebuilds search/embeddings.')) return;
	    if (adminReindexStatusEl) adminReindexStatusEl.textContent = 'Starting refresh...';
	    try {
	      const payload = await apiJson('/admin/refresh', {
	        method: 'POST',
	        body: {
	          compute_embeddings: computeEmb,
	          embedding_max_chars: embMax,
	          embedding_batch_size: embBatch,
	          include_edits: includeEdits,
	        }
	      });
	      renderReindexStatus(payload);
	      fetchReindexStatus().catch(() => {});
	    } catch (e) {
	      if (adminReindexStatusEl) adminReindexStatusEl.textContent = `Refresh failed: ${e?.raw ? String(e.raw) : String(e)}`;
	    }
	  }

		  if (adminReindexBtnEl) adminReindexBtnEl.addEventListener('click', () => startReindex());
		  if (adminReindexRefreshBtnEl) adminReindexRefreshBtnEl.addEventListener('click', () => startRefresh());

	  function setAdminPublishStatus(text, { error = false } = {}) {
	    if (!adminPublishStatusEl) return;
	    adminPublishStatusEl.textContent = String(text || '');
	    adminPublishStatusEl.style.color = error ? 'var(--danger)' : 'var(--muted)';
	  }

	  function renderPublishRequests(items) {
	    if (!adminPublishListEl) return;
	    adminPublishListEl.innerHTML = '';
	    const list = Array.isArray(items) ? items : [];
	    if (!list.length) {
	      adminPublishListEl.innerHTML = `<div class="tiny muted">No pending requests.</div>`;
	      return;
	    }
	    list.forEach((req) => {
	      const item = document.createElement('div');
	      item.className = 'item';
	      const docLabel = `${req.doc_title || req.doc_id} â€º ${req.page_title || req.page_id}`;
	      const who = req.author_username ? `${req.author_username}` : (req.author_id || 'unknown');
	      const when = req.updated_at ? new Date(req.updated_at).toLocaleString() : '';
	      item.innerHTML = `
	        <div class="top">
	          <span class="badge">${docLabel}</span>
	          <span class="badge">${who}</span>
	        </div>
	        <div class="tagline">Updated: ${when}</div>
	      `;
	      const actions = document.createElement('div');
	      actions.className = 'inline';
	      actions.style.marginTop = '8px';

	      const openBtn = document.createElement('button');
	      openBtn.className = 'btn ghost small';
	      openBtn.textContent = 'OPEN';
	      openBtn.addEventListener('click', () => {
	        openDocsReader({
	          doc_id: req.doc_id,
	          page_id: req.page_id,
	          version: docsState.version || req.version || null,
	          fullscreen: true,
	        });
	      });

	      const approveBtn = document.createElement('button');
	      approveBtn.className = 'btn primary small';
	      approveBtn.textContent = 'APPROVE';
	      approveBtn.addEventListener('click', async () => {
	        if (!confirm(`Approve publish for "${docLabel}"?`)) return;
	        setAdminPublishStatus('Approvingâ€¦');
	        try {
	          await apiJson(
	            `/admin/publish-requests/${encodeURIComponent(req.doc_id)}/${encodeURIComponent(req.page_id)}/approve`,
	            { method: 'POST', body: { version: docsState.version || null } }
	          );
	          await loadPublishRequests();
	          setAdminPublishStatus('Approved.');
	        } catch (e) {
	          const raw = e?.raw ? String(e.raw) : String(e);
	          setAdminPublishStatus(`Approve failed: ${raw}`, { error: true });
	        }
	      });

	      const rejectBtn = document.createElement('button');
	      rejectBtn.className = 'btn ghost small';
	      rejectBtn.textContent = 'REJECT';
	      rejectBtn.addEventListener('click', async () => {
	        const note = prompt('Reject reason (optional):', '') || '';
	        setAdminPublishStatus('Rejectingâ€¦');
	        try {
	          await apiJson(
	            `/admin/publish-requests/${encodeURIComponent(req.doc_id)}/${encodeURIComponent(req.page_id)}/reject`,
	            { method: 'POST', body: { version: docsState.version || null, note: note || null } }
	          );
	          await loadPublishRequests();
	          setAdminPublishStatus('Rejected.');
	        } catch (e) {
	          const raw = e?.raw ? String(e.raw) : String(e);
	          setAdminPublishStatus(`Reject failed: ${raw}`, { error: true });
	        }
	      });

	      actions.appendChild(openBtn);
	      actions.appendChild(approveBtn);
	      actions.appendChild(rejectBtn);
	      item.appendChild(actions);
	      adminPublishListEl.appendChild(item);
	    });
	  }

	  async function loadPublishRequests() {
	    if (!adminPublishListEl) return;
	    setAdminPublishStatus('Loadingâ€¦');
	    try {
	      const ver = docsState.version || null;
	      const qs = ver
	        ? `?version=${encodeURIComponent(ver)}&status=pending`
	        : '?status=pending';
	      const payload = await apiJson(`/admin/publish-requests${qs}`);
	      renderPublishRequests(payload?.requests || []);
	      setAdminPublishStatus('');
	    } catch (e) {
	      const raw = e?.raw ? String(e.raw) : String(e);
	      setAdminPublishStatus(`Failed to load requests: ${raw}`, { error: true });
	    }
	  }

	  adminPublishRefreshBtnEl?.addEventListener('click', () => loadPublishRequests());

			  function setAdminUsersStatus(text, { error = false } = {}) {
			    if (!adminUsersStatusEl) return;
			    adminUsersStatusEl.textContent = String(text || '');
			    adminUsersStatusEl.style.color = error ? 'var(--danger)' : 'var(--muted)';
			  }

			  function setAdminEditStatus(text, { error = false } = {}) {
			    if (!adminEditUserStatusEl) return;
			    adminEditUserStatusEl.textContent = String(text || '');
			    adminEditUserStatusEl.style.color = error ? 'var(--danger)' : 'var(--muted)';
			  }

			  function selectAdminUser(u) {
			    if (!u) return;
			    adminSelectedUserId = String(u.user_id || '');
			    adminSelectedUserDisabled = Boolean(u.disabled_at);
			    if (adminEditUserUsernameEl) adminEditUserUsernameEl.value = u.username || '';
			    if (adminEditUserEmailEl) adminEditUserEmailEl.value = u.email || '';
			    if (adminEditUserRoleEl) adminEditUserRoleEl.value = String(u.role || 'client');
			    if (adminEditUserDocsEditEl) adminEditUserDocsEditEl.checked = Boolean(u.docs_edit);
			    if (adminEditUserDocsPublishEl) adminEditUserDocsPublishEl.checked = Boolean(u.docs_publish);
			    if (adminEditUserDisabledEl) adminEditUserDisabledEl.checked = adminSelectedUserDisabled;
			    if (adminEditUserGreetingEl) adminEditUserGreetingEl.value = u.greeting || '';
			    if (adminEditUserPasswordEl) adminEditUserPasswordEl.value = '';
			    if (adminUserEditDetailsEl) adminUserEditDetailsEl.open = true;
			    setAdminEditStatus(`Selected: ${u.username || u.user_id}`);
			    renderAdminUsers(adminUsersCache);
			  }

			  function clearAdminUserSelection() {
			    adminSelectedUserId = null;
			    adminSelectedUserDisabled = false;
			    if (adminEditUserUsernameEl) adminEditUserUsernameEl.value = '';
			    if (adminEditUserEmailEl) adminEditUserEmailEl.value = '';
			    if (adminEditUserRoleEl) adminEditUserRoleEl.value = 'client';
			    if (adminEditUserDocsEditEl) adminEditUserDocsEditEl.checked = false;
			    if (adminEditUserDocsPublishEl) adminEditUserDocsPublishEl.checked = false;
			    if (adminEditUserDisabledEl) adminEditUserDisabledEl.checked = false;
			    if (adminEditUserGreetingEl) adminEditUserGreetingEl.value = '';
			    if (adminEditUserPasswordEl) adminEditUserPasswordEl.value = '';
			    setAdminEditStatus('');
			    renderAdminUsers(adminUsersCache);
			  }

			  async function saveAdminUserEdits() {
			    if (!adminSelectedUserId) {
			      setAdminEditStatus('Select a user first.', { error: true });
			      return;
			    }
			    const emailRaw = String(adminEditUserEmailEl?.value || '').trim();
			    const role = String(adminEditUserRoleEl?.value || 'client').trim();
			    const docsEdit = Boolean(adminEditUserDocsEditEl?.checked);
			    const docsPublish = Boolean(adminEditUserDocsPublishEl?.checked);
			    const desiredDisabled = Boolean(adminEditUserDisabledEl?.checked);
			    const greetingRaw = String(adminEditUserGreetingEl?.value || '').trim();
			    const password = String(adminEditUserPasswordEl?.value || '');
			    const body = {
			      email: emailRaw ? emailRaw : null,
			      role,
			      docs_edit: docsEdit,
			      docs_publish: docsPublish,
			      greeting: greetingRaw,
			    };
			    if (desiredDisabled !== adminSelectedUserDisabled) body.disabled = desiredDisabled;
			    if (password) body.password = password;

			    setAdminEditStatus('Savingâ€¦');
			    try {
			      await apiJson(`/auth/users/${encodeURIComponent(adminSelectedUserId)}`, { method: 'PATCH', body });
			      if (adminEditUserPasswordEl) adminEditUserPasswordEl.value = '';
			      await loadAdminUsers();
			      setAdminEditStatus('Saved.');
			    } catch (e) {
			      const raw = e?.raw ? String(e.raw) : String(e);
			      setAdminEditStatus(`Save failed: ${raw}`, { error: true });
			    }
			  }

			  function renderAdminUsers(users) {
			    if (!adminUsersListEl) return;
			    adminUsersListEl.innerHTML = '';
			    (users || []).forEach((u) => {
			      const item = document.createElement('div');
			      item.className = 'item';
			      const uid = String(u.user_id || '');
			      if (uid && adminSelectedUserId && uid === adminSelectedUserId) item.classList.add('selected');
			      if (u.disabled_at) item.classList.add('disabled');
			      item.addEventListener('click', () => selectAdminUser(u));
			      const top = document.createElement('div');
			      top.className = 'top';
			      const left = document.createElement('div');
			      left.textContent = u.username || u.user_id;
			      const badge = document.createElement('div');
			      badge.className = 'badge';
			      badge.textContent = u.role || 'â€”';
			      top.appendChild(left);
			      top.appendChild(badge);
			      item.appendChild(top);

			      const sub = document.createElement('div');
			      sub.className = 'tagline';
			      const parts = [];
			      if (u.disabled_at) parts.push('DISABLED');
			      if (u.email) parts.push(String(u.email));
			      if (u.greeting) parts.push(`Greeting: ${u.greeting}`);
			      if (!parts.length) parts.push(`Created: ${u.created_at || 'â€”'}`);
			      sub.textContent = parts.join(' Â· ');
			      item.appendChild(sub);
			      adminUsersListEl.appendChild(item);
			    });
			    if (!(users || []).length) {
		      const empty = document.createElement('div');
		      empty.className = 'tiny muted';
		      empty.textContent = 'No users found.';
		      adminUsersListEl.appendChild(empty);
		    }
		  }

			  async function loadAdminUsers() {
			    setAdminUsersStatus('Loading usersâ€¦');
			    try {
			      const data = await apiJson('/auth/users');
			      adminUsersCache = data.users || [];
			      renderAdminUsers(adminUsersCache);
			      if (adminSelectedUserId) {
			        const u = adminUsersCache.find((x) => String(x.user_id || '') === String(adminSelectedUserId));
			        if (u) selectAdminUser(u);
			        else clearAdminUserSelection();
			      }
			      setAdminUsersStatus(`Loaded ${data.users?.length || 0} users.`);
			    } catch (e) {
			      const raw = e?.raw ? String(e.raw) : String(e);
			      setAdminUsersStatus(`Failed to load users: ${raw}`, { error: true });
			      renderAdminUsers([]);
			    }
			  }

			  async function createAdminUser() {
			    const username = String(adminNewUserUsernameEl?.value || '').trim();
			    const email = String(adminNewUserEmailEl?.value || '').trim();
			    const password = String(adminNewUserPasswordEl?.value || '');
			    const role = String(adminNewUserRoleEl?.value || 'client').trim();
			    const greeting = String(adminNewUserGreetingEl?.value || '').trim();
			    if (!username || !password) {
			      setAdminUsersStatus('Username and password required.', { error: true });
		      return;
		    }
			    setAdminUsersStatus('Creating userâ€¦');
			    try {
			      await apiJson('/auth/users', { method: 'POST', body: { username, email: email || null, password, role, greeting: greeting || null } });
			      if (adminNewUserPasswordEl) adminNewUserPasswordEl.value = '';
			      if (adminNewUserEmailEl) adminNewUserEmailEl.value = '';
			      await loadAdminUsers();
			      setAdminUsersStatus(`Created user ${username}.`);
			    } catch (e) {
			      const raw = e?.raw ? String(e.raw) : String(e);
			      setAdminUsersStatus(`Create failed: ${raw}`, { error: true });
			    }
			  }

			  adminUsersRefreshBtnEl?.addEventListener('click', () => loadAdminUsers());
			  adminUsersCreateBtnEl?.addEventListener('click', () => createAdminUser());
			  adminEditUserSaveBtnEl?.addEventListener('click', () => saveAdminUserEdits());
			  adminEditUserClearBtnEl?.addEventListener('click', () => clearAdminUserSelection());

		  async function loadHealthInfo() {
		    try {
		      const health = await apiJson('/health');
		      if (appVersionEl && health?.app_version) appVersionEl.textContent = health.app_version;
		      if (adminDocsVersionEl) adminDocsVersionEl.textContent = health.docs_version ?? 'â€”';
		      if (adminDatastoreReadyEl) adminDatastoreReadyEl.textContent = String(health.datastore_ready ?? 'â€”');
		      if (adminLmstudioUrlEl) adminLmstudioUrlEl.textContent = health.lmstudio_base_url ?? 'â€”';
		      return health;
		    } catch (e) {
		      return null;
		    }
		  }

		  async function loadAdminPanel() {
		    adminSaveHintEl.textContent = '';
		    adminApiBaseEl.textContent = apiBase;

	    await loadHealthInfo();

		    adminBundle = await apiJson('/admin/settings');
			    const effective = adminBundle.effective || {};
			    const retrieval = effective.retrieval || {};
			    const llm = effective.llm || {};
			    const web = effective.web || {};
			    loadAdminUsers().catch(() => {});
			    loadPublishRequests().catch(() => {});

		    adminRetrievalModeEl.value = retrieval.mode || 'bm25';
		    adminRetrievalKEl.value = retrieval.k_default ?? 8;
		    adminMaxCitationsEl.value = retrieval.max_citations ?? 8;
		    adminMaxImagesEl.value = retrieval.max_images ?? 6;
		    adminDocPriorityBoostEl.value = retrieval.doc_priority_boost ?? 0.0;
		    adminHeadingBoostEl.value = retrieval.heading_boost ?? 0.0;
		    adminDocPriorityEl.value = Array.isArray(retrieval.doc_priority) ? retrieval.doc_priority.join('\n') : '';
		    adminMaxPerPageEl.value = retrieval?.dedupe?.max_per_page ?? 3;
		    adminMaxPerDocEl.value = retrieval?.dedupe?.max_per_doc ?? 12;
		    adminRrfKEl.value = retrieval?.hybrid?.rrf_k ?? 60;
		    adminBm25WeightEl.value = retrieval?.hybrid?.bm25_weight ?? 1.0;
		    adminEmbWeightEl.value = retrieval?.hybrid?.embedding_weight ?? 1.0;
		    adminBm25CandidatesEl.value = retrieval?.hybrid?.bm25_candidates ?? 120;
		    adminEmbCandidatesEl.value = retrieval?.hybrid?.embedding_candidates ?? 120;
		    adminMmrEnabledEl.checked = Boolean(retrieval?.mmr?.enabled ?? true);
		    adminMmrUseEmbeddingsEl.checked = Boolean(retrieval?.mmr?.use_embeddings ?? true);
		    adminMmrLambdaEl.value = retrieval?.mmr?.lambda ?? 0.8;
		    adminMmrCandidatesEl.value = retrieval?.mmr?.candidates ?? 80;
		    adminExpandNeighborsEl.value = retrieval?.expand?.neighbors ?? 1;
		    adminExpandMaxCharsEl.value = retrieval?.expand?.max_chars ?? 4200;
		    if (adminExpandIncludeImagesEl) {
		      adminExpandIncludeImagesEl.checked = Boolean(retrieval?.expand?.include_images ?? false);
		    }
		    const toolCalls = retrieval?.tool_calls || {};
		    if (adminToolCallsEnabledEl) {
		      adminToolCallsEnabledEl.checked = Boolean(toolCalls.enabled ?? true);
		    }
		    if (adminToolCallsMaxEl) {
		      adminToolCallsMaxEl.value = toolCalls.max_calls ?? 12;
		    }

		    const summary = retrieval?.summary || {};
		    if (adminSummaryEnabledEl) adminSummaryEnabledEl.checked = Boolean(summary.enabled ?? true);
		    if (adminSummaryModelEl) adminSummaryModelEl.value = summary.model ?? '';
		    if (adminSummaryKEl) adminSummaryKEl.value = summary.k ?? 12;
		    if (adminSummaryMaxPagesEl) adminSummaryMaxPagesEl.value = summary.max_pages ?? 20;
		    if (adminSummaryUnitTokensEl) adminSummaryUnitTokensEl.value = summary.unit_max_tokens ?? 900;
		    if (adminSummaryMaxCharsEl) adminSummaryMaxCharsEl.value = summary.max_input_chars ?? 6000;
		    if (adminSummaryMaxTokensEl) adminSummaryMaxTokensEl.value = summary.max_output_tokens ?? 280;

		    adminModelIdEl.value = llm.model ?? '';
		    adminTimeoutSEl.value = llm.timeout_s ?? 180;
		    adminTemperatureEl.value = llm.temperature ?? 0.2;
		    adminMaxTokensEl.value = llm.max_tokens ?? 800;

		    adminWebEnabledEl.checked = Boolean(web.enabled ?? true);
		    adminWebTimeoutSEl.value = web.timeout_s ?? 15;
		    adminWebMaxCharsEl.value = web.max_chars ?? 20000;
			    adminWebMaxBytesEl.value = web.max_bytes ?? 1000000;
			    adminWebMaxUrlsEl.value = web.max_urls_per_message ?? 2;
			    adminWebSearchKEl.value = web.search_k ?? 5;

		    _loadPromptTemplates(effective);
		    const preferredRole = PROMPT_ROLES.includes(String(authState?.role || '')) ? String(authState.role) : 'admin';
		    _setPromptRole(preferredRole, { preserveCurrent: false });

		    chatKDefault = Number(retrieval.k_default ?? 8);
		    _syncPromptPreview();

		    await fetchReindexStatus().catch(() => {});
		  }

	  function applyDefaultsToForm() {
	    if (!adminBundle?.defaults) return;
	    const d = adminBundle.defaults;
		    const retrieval = d.retrieval || {};
		    const llm = d.llm || {};
		    const web = d.web || {};

		    adminRetrievalModeEl.value = retrieval.mode || 'bm25';
		    adminRetrievalKEl.value = retrieval.k_default ?? 8;
		    adminMaxCitationsEl.value = retrieval.max_citations ?? 8;
		    adminMaxImagesEl.value = retrieval.max_images ?? 6;
		    adminDocPriorityBoostEl.value = retrieval.doc_priority_boost ?? 0.0;
		    adminHeadingBoostEl.value = retrieval.heading_boost ?? 0.0;
		    adminDocPriorityEl.value = Array.isArray(retrieval.doc_priority) ? retrieval.doc_priority.join('\n') : '';
		    adminMaxPerPageEl.value = retrieval?.dedupe?.max_per_page ?? 3;
		    adminMaxPerDocEl.value = retrieval?.dedupe?.max_per_doc ?? 12;
		    adminRrfKEl.value = retrieval?.hybrid?.rrf_k ?? 60;
		    adminBm25WeightEl.value = retrieval?.hybrid?.bm25_weight ?? 1.0;
		    adminEmbWeightEl.value = retrieval?.hybrid?.embedding_weight ?? 1.0;
		    adminBm25CandidatesEl.value = retrieval?.hybrid?.bm25_candidates ?? 120;
		    adminEmbCandidatesEl.value = retrieval?.hybrid?.embedding_candidates ?? 120;
		    adminMmrEnabledEl.checked = Boolean(retrieval?.mmr?.enabled ?? true);
		    adminMmrUseEmbeddingsEl.checked = Boolean(retrieval?.mmr?.use_embeddings ?? true);
		    adminMmrLambdaEl.value = retrieval?.mmr?.lambda ?? 0.8;
		    adminMmrCandidatesEl.value = retrieval?.mmr?.candidates ?? 80;
		    adminExpandNeighborsEl.value = retrieval?.expand?.neighbors ?? 1;
		    adminExpandMaxCharsEl.value = retrieval?.expand?.max_chars ?? 4200;
		    if (adminExpandIncludeImagesEl) {
		      adminExpandIncludeImagesEl.checked = Boolean(retrieval?.expand?.include_images ?? false);
		    }
		    const toolCalls = retrieval?.tool_calls || {};
		    if (adminToolCallsEnabledEl) {
		      adminToolCallsEnabledEl.checked = Boolean(toolCalls.enabled ?? true);
		    }
		    if (adminToolCallsMaxEl) {
		      adminToolCallsMaxEl.value = toolCalls.max_calls ?? 12;
		    }

		    const summary = retrieval?.summary || {};
		    if (adminSummaryEnabledEl) adminSummaryEnabledEl.checked = Boolean(summary.enabled ?? true);
		    if (adminSummaryModelEl) adminSummaryModelEl.value = summary.model ?? '';
		    if (adminSummaryKEl) adminSummaryKEl.value = summary.k ?? 12;
		    if (adminSummaryMaxPagesEl) adminSummaryMaxPagesEl.value = summary.max_pages ?? 20;
		    if (adminSummaryUnitTokensEl) adminSummaryUnitTokensEl.value = summary.unit_max_tokens ?? 900;
		    if (adminSummaryMaxCharsEl) adminSummaryMaxCharsEl.value = summary.max_input_chars ?? 6000;
		    if (adminSummaryMaxTokensEl) adminSummaryMaxTokensEl.value = summary.max_output_tokens ?? 280;

		    adminModelIdEl.value = llm.model ?? '';
		    adminTimeoutSEl.value = llm.timeout_s ?? 180;
		    adminTemperatureEl.value = llm.temperature ?? 0.2;
		    adminMaxTokensEl.value = llm.max_tokens ?? 800;

		    adminWebEnabledEl.checked = Boolean(web.enabled ?? true);
		    adminWebTimeoutSEl.value = web.timeout_s ?? 15;
		    adminWebMaxCharsEl.value = web.max_chars ?? 20000;
		    adminWebMaxBytesEl.value = web.max_bytes ?? 1000000;
			    adminWebMaxUrlsEl.value = web.max_urls_per_message ?? 2;
			    adminWebSearchKEl.value = web.search_k ?? 5;

		    _loadPromptTemplates(d);
		    _setPromptRole(adminActivePromptRole || 'admin', { preserveCurrent: false });
		    adminSaveHintEl.textContent = 'Loaded defaults (not yet applied).';
		    _syncPromptPreview();
		  }

		  async function applyAdminSettings() {
		    adminSaveHintEl.textContent = '';
		    if (adminActivePromptRole && adminSystemPromptEl) {
		      adminPromptTemplates[adminActivePromptRole] = String(adminSystemPromptEl.value || '');
		    }
		    const templates = {};
		    PROMPT_ROLES.forEach((r) => { templates[r] = String(adminPromptTemplates[r] ?? ''); });
		    // Keep legacy single template for backward compatibility (client template is the safest default).
		    const baseTmpl = (templates.client && templates.client.trim()) ? templates.client : String(adminSystemPromptEl?.value || '');
		    if (!baseTmpl.includes('{{context}}')) {
		      adminSaveHintEl.textContent = 'Error: base prompt template must include {{context}}.';
		      return;
		    }
		    for (const [role, t] of Object.entries(templates)) {
		      if (String(t || '').trim() && !String(t).includes('{{context}}')) {
		        adminSaveHintEl.textContent = `Error: ${role} prompt must include {{context}}.`;
		        return;
		      }
		    }

			    const retrieval = {
			      mode: adminRetrievalModeEl.value || 'bm25',
			      k_default: Number(adminRetrievalKEl.value || 8),
		      max_citations: Number(adminMaxCitationsEl.value || 8),
		      max_images: Number(adminMaxImagesEl.value || 6),
		      doc_priority_boost: Number(adminDocPriorityBoostEl.value || 0),
		      heading_boost: Number(adminHeadingBoostEl.value || 0),
		      mmr: {
		        enabled: Boolean(adminMmrEnabledEl.checked),
		        lambda: Number(adminMmrLambdaEl.value || 0.8),
		        candidates: Number(adminMmrCandidatesEl.value || 80),
		        use_embeddings: Boolean(adminMmrUseEmbeddingsEl.checked)
		      },
		      expand: {
		        neighbors: Number(adminExpandNeighborsEl.value || 0),
		        max_chars: Number(adminExpandMaxCharsEl.value || 0),
		        include_images: Boolean(adminExpandIncludeImagesEl?.checked)
		      },
		      tool_calls: {
		        enabled: Boolean(adminToolCallsEnabledEl?.checked),
		        max_calls: Number(adminToolCallsMaxEl?.value || 0)
		      },
		      summary: {
		        enabled: Boolean(adminSummaryEnabledEl?.checked),
		        model: String(adminSummaryModelEl?.value || '').trim(),
		        k: Number(adminSummaryKEl?.value || 12),
		        max_pages: Number(adminSummaryMaxPagesEl?.value || 20),
		        unit_max_tokens: Number(adminSummaryUnitTokensEl?.value || 900),
		        max_input_chars: Number(adminSummaryMaxCharsEl?.value || 6000),
		        max_output_tokens: Number(adminSummaryMaxTokensEl?.value || 280)
		      },
		      dedupe: {
		        max_per_page: Number(adminMaxPerPageEl.value || 0),
		        max_per_doc: Number(adminMaxPerDocEl.value || 0)
		      },
		      hybrid: {
		        rrf_k: Number(adminRrfKEl.value || 60),
		        bm25_weight: Number(adminBm25WeightEl.value || 1.0),
		        embedding_weight: Number(adminEmbWeightEl.value || 1.0),
		        bm25_candidates: Number(adminBm25CandidatesEl.value || 120),
		        embedding_candidates: Number(adminEmbCandidatesEl.value || 120)
		      },
		      doc_priority: _linesToList(adminDocPriorityEl.value)
		    };
		    const llm = {
		      model: String(adminModelIdEl.value || '').trim(),
		      timeout_s: Number(adminTimeoutSEl.value || 180),
		      temperature: Number(adminTemperatureEl.value || 0.2),
		      max_tokens: Number(adminMaxTokensEl.value || 800)
		    };
		    const web = {
		      enabled: Boolean(adminWebEnabledEl.checked),
		      timeout_s: Number(adminWebTimeoutSEl.value || 15),
		      max_chars: Number(adminWebMaxCharsEl.value || 20000),
		      max_bytes: Number(adminWebMaxBytesEl.value || 1000000),
		      max_urls_per_message: Number(adminWebMaxUrlsEl.value || 2),
		      search_k: Number(adminWebSearchKEl.value || 5)
		    };
			    const payload = {
			      settings: {
			        system_prompt_template: baseTmpl,
			        system_prompt_templates: templates,
			        retrieval,
			        llm,
			        web
			      }
			    };

	    try {
	      adminBundle = await apiJson('/admin/settings', { method: 'POST', body: payload });
	      const effective = adminBundle.effective || {};
	      chatKDefault = Number(effective?.retrieval?.k_default ?? retrieval.k_default ?? 8);
	      adminSaveHintEl.textContent = 'Saved. New settings apply immediately.';
	    } catch (e) {
	      adminSaveHintEl.textContent = `Save failed: ${e?.raw ? String(e.raw) : String(e)}`;
	    }
	  }

	  // Load initial settings (so chat uses server defaults)
	  (async () => {
	    try {
	      const b = await apiJson('/admin/settings');
	      adminBundle = b;
	      const k = b?.effective?.retrieval?.k_default;
	      if (typeof k === 'number') chatKDefault = k;
	    } catch (e) {
	      // Backend may be down; keep defaults.
	    }
	  })();
	  loadHealthInfo().catch(() => {});

	  function setEmptyStateVisible(visible) {
	    emptyState.style.display = visible ? 'flex' : 'none';
	  }

	  // ---------- Markdown renderer ----------
  function escapeHtml(s) {
    return String(s ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/\"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function normalizeUrl(url) {
    const u = String(url || '').trim();
    if (!u) return '';
    if (u.startsWith('#')) return u;
    if (/^(https?:|data:|blob:)/i.test(u)) return u;
    if (u.startsWith('/')) return apiBase + u;
    return u;
  }

  function parseImageWidth(rawUrl) {
    let src = String(rawUrl || '').trim();
    if (!src) return { src: '', width: null };
    let widthSpec = null;
    const pipeIdx = src.indexOf('|');
    if (pipeIdx >= 0) {
      const tail = src.slice(pipeIdx + 1).trim();
      src = src.slice(0, pipeIdx).trim();
      const m = tail.match(/^(?:width|w)=(.+)$/i);
      if (m) widthSpec = m[1].trim();
    }
    const hashIdx = src.indexOf('#');
    const queryIdx = src.indexOf('?');
    if (!widthSpec && queryIdx >= 0) {
      const query = src.slice(queryIdx + 1, hashIdx >= 0 ? hashIdx : undefined);
      const params = new URLSearchParams(query);
      widthSpec = params.get('width') || params.get('w');
    }
    if (!widthSpec && hashIdx >= 0) {
      const fragment = src.slice(hashIdx + 1);
      if (fragment.includes('=')) {
        const params = new URLSearchParams(fragment);
        widthSpec = params.get('width') || params.get('w');
      }
    }
    if (!widthSpec) return { src, width: null };
    const m = widthSpec.match(/^(\d+(?:\.\d+)?)(%|px|mm|cm)?$/i);
    if (!m) return { src, width: null };
    const value = Number(m[1]);
    const unit = (m[2] || 'px').toLowerCase();
    return {
      src,
      width: { value, unit, css: `${value}${unit}` },
    };
  }

  function applyImageWidthStyle(token, width) {
    if (!width || !width.css) return;
    const existing = token.attrGet('style') || '';
    const suffix = `width:${width.css};height:auto;max-width:100%;`;
    const merged = existing ? `${existing};${suffix}` : suffix;
    token.attrSet('style', merged);
  }

  function mdInline(text) {
    const raw = String(text ?? '');
    const stash = [];
    const put = (html) => {
      const idx = stash.length;
      stash.push(String(html));
      return `\u0000${idx}\u0000`;
    };

    let s = raw;

    s = s.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (m, alt, url) => {
      const parsed = parseImageWidth(url);
      const src = normalizeUrl(parsed.src);
      if (!src) return '';
      const style = parsed.width ? ` style="${parsed.width.css ? `width:${parsed.width.css};height:auto;max-width:100%;` : ''}"` : '';
      return put(`<img src="${src}" alt="${escapeHtml(alt || '')}"${style}>`);
    });

    s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, label, url) => {
      const href = normalizeUrl(url);
      if (!href) return escapeHtml(label || '');
      return put(`<a href="${href}" target="_blank" rel="noreferrer">${escapeHtml(label || '')}</a>`);
    });

    s = s.replace(/`([^`]+)`/g, (m, code) => put(`<code>${escapeHtml(code)}</code>`));
    s = escapeHtml(s);
    s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    s = s.replace(/(^|[^*])\*([^*\n]+)\*(?!\*)/g, '$1<em>$2</em>');
    s = s.replace(/\[(\d{1,3})\]/g, '<span class="cite">[$1]</span>');
    s = s.replace(/\n/g, '<br>');
    s = s.replace(/\u0000(\d+)\u0000/g, (m, n) => stash[Number(n)] ?? '');
    return s;
  }

  function slugifyId(text) {
    let s = String(text || '').toLowerCase().trim();
    s = s.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '$1');
    s = s.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '$1');
    s = s.replace(/`+/g, '');
    s = s.replace(/[*_]+/g, '');
    try { s = s.normalize('NFKD'); } catch (e) {}
    s = s.replace(/[\u0300-\u036f]/g, '');
    s = s.replace(/[^a-z0-9]+/g, '-');
    s = s.replace(/-+/g, '-').replace(/^-|-$/g, '');
    return s || 'section';
  }

  function renderMarkdownFallback(mdText, { addHeadingIds = false } = {}) {
    const src = String(mdText || '').replace(/\r\n?/g, '\n');
    const lines = src.split('\n');
    let html = '';
    let inCode = false;
    let codeBuf = [];
    let paraBuf = [];
    let listTag = null;
    let quoteBuf = [];
    const usedHeadingIds = new Map();

    function splitTableRow(row) {
      let s = String(row || '').trim();
      if (s.startsWith('|')) s = s.slice(1);
      if (s.endsWith('|')) s = s.slice(0, -1);
      return s.split('|').map((c) => c.trim());
    }

    function isTableSeparator(row) {
      const cells = splitTableRow(row);
      if (!cells.length) return false;
      return cells.every((c) => {
        const t = String(c || '').trim();
        if (!t) return true;
        return /^:?-+:?$/.test(t);
      });
    }

    function flushParagraph() {
      if (!paraBuf.length) return;
      html += `<p>${mdInline(paraBuf.join('\n'))}</p>`;
      paraBuf = [];
    }

    function closeList() {
      if (!listTag) return;
      html += `</${listTag}>`;
      listTag = null;
    }

    function flushQuote() {
      if (!quoteBuf.length) return;
      const rawLines = quoteBuf.map((l) => l.replace(/^\s*>\s?/, ''));
      const first = (rawLines[0] || '').trim();
      const admon = first.match(/^\[!([A-Z]+)\]\s*(.*)$/i);
      if (admon) {
        const kind = String(admon[1] || 'note').toLowerCase();
        const title = (admon[2] || admon[1] || 'Note').trim();
        const bodyLines = rawLines.slice(1);
        const bodyHtml = bodyLines.length
          ? bodyLines.map((l) => `<p>${mdInline(l)}</p>`).join('')
          : '';
        html += `<div class="admonition ${escapeHtml(kind)}">`;
        html += `<div class="admonition-title">${escapeHtml(title)}</div>`;
        if (bodyHtml) html += `<div class="admonition-body">${bodyHtml}</div>`;
        html += `</div>`;
      } else {
        const bodyHtml = rawLines.map((l) => `<p>${mdInline(l)}</p>`).join('');
        html += `<blockquote>${bodyHtml}</blockquote>`;
      }
      quoteBuf = [];
    }

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const fence = line.match(/^\s*```/);
      if (fence) {
        flushParagraph();
        closeList();
        if (inCode) {
          html += `<pre><code>${escapeHtml(codeBuf.join('\n'))}</code></pre>`;
          codeBuf = [];
          inCode = false;
        } else {
          inCode = true;
        }
        continue;
      }

      if (inCode) {
        codeBuf.push(line);
        continue;
      }

      const isQuote = /^\s*>\s?/.test(line);
      if (isQuote) {
        flushParagraph();
        closeList();
        quoteBuf.push(line);
        continue;
      }
      if (quoteBuf.length) {
        flushQuote();
      }

      if (/^\s*(---|\*\*\*|___)\s*$/.test(line)) {
        flushParagraph();
        closeList();
        html += '<hr>';
        continue;
      }

      if (line.includes('|') && i + 1 < lines.length && isTableSeparator(lines[i + 1])) {
        flushParagraph();
        closeList();

        const headCells = splitTableRow(line);
        const bodyRows = [];
        let j = i + 2;
        while (j < lines.length) {
          const rowLine = lines[j];
          if (/^\s*$/.test(rowLine)) break;
          if (!rowLine.includes('|')) break;
          bodyRows.push(splitTableRow(rowLine));
          j++;
        }

        html += '<table><thead><tr>';
        html += headCells.map((c) => `<th>${mdInline(c)}</th>`).join('');
        html += '</tr></thead>';
        if (bodyRows.length) {
          html += '<tbody>';
          html += bodyRows
            .map((r) => `<tr>${r.map((c) => `<td>${mdInline(c)}</td>`).join('')}</tr>`)
            .join('');
          html += '</tbody>';
        }
        html += '</table>';
        i = j - 1;
        continue;
      }

      const h = line.match(/^(#{1,6})\s+(.*)$/);
      if (h) {
        flushParagraph();
        closeList();
        const lvl = Math.min(6, h[1].length);
        const headingText = h[2].trim();
        let idAttr = '';
        if (addHeadingIds) {
          const base = slugifyId(headingText);
          const next = (usedHeadingIds.get(base) || 0) + 1;
          usedHeadingIds.set(base, next);
          const id = next > 1 ? `${base}-${next}` : base;
          idAttr = ` id="${escapeHtml(id)}"`;
        }
        html += `<h${lvl}${idAttr}>${mdInline(headingText)}</h${lvl}>`;
        continue;
      }

      const ol = line.match(/^\s*(\d+)\.\s+(.*)$/);
      const ul = !ol ? line.match(/^\s*[-*]\s+(.*)$/) : null;
      if (ol || ul) {
        flushParagraph();
        const tag = ol ? 'ol' : 'ul';
        if (listTag !== tag) {
          closeList();
          html += `<${tag}>`;
          listTag = tag;
        }
        const itemText = (ol ? ol[2] : ul[1]).trim();
        html += `<li>${mdInline(itemText)}</li>`;
        continue;
      }

      if (/^\s*$/.test(line)) {
        flushParagraph();
        closeList();
        continue;
      }

      paraBuf.push(line);
    }

    if (inCode) {
      html += `<pre><code>${escapeHtml(codeBuf.join('\n'))}</code></pre>`;
    }
    flushQuote();
    flushParagraph();
    closeList();
    return html;
  }

  function normalizeAdmonitions(mdText) {
    const src = String(mdText || '').replace(/\r\n?/g, '\n');
    const lines = src.split('\n');
    const out = [];
    let inCode = false;
    let i = 0;
    while (i < lines.length) {
      const line = lines[i];
      const trimmed = line.trim();
      if (trimmed.startsWith('```')) {
        inCode = !inCode;
        out.push(line);
        i += 1;
        continue;
      }
      if (inCode) {
        out.push(line);
        i += 1;
        continue;
      }
      const match = line.match(/^\s*>\s*\[!(TIP|INFO|WARNING|NOTE)\]\s*(.*)$/i);
      if (!match) {
        out.push(line);
        i += 1;
        continue;
      }
      const kind = String(match[1]).toLowerCase();
      const title = String(match[2] || '').trim();
      out.push(`::: ${kind}${title ? ` ${title}` : ''}`);
      i += 1;
      while (i < lines.length) {
        const next = lines[i];
        if (/^\s*>\s?/.test(next)) {
          out.push(next.replace(/^\s*>\s?/, ''));
          i += 1;
          continue;
        }
        break;
      }
      out.push(':::');
    }
    return out.join('\n');
  }

  function wrapCitations(html) {
    const root = document.createElement('div');
    root.innerHTML = html;
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
    const nodes = [];
    while (walker.nextNode()) nodes.push(walker.currentNode);
    const citeRe = /\[(\d{1,3})\]/g;
    nodes.forEach((node) => {
      const parent = node.parentElement;
      if (!parent || parent.tagName === 'CODE' || parent.tagName === 'PRE') return;
      const text = node.nodeValue || '';
      if (!citeRe.test(text)) return;
      citeRe.lastIndex = 0;
      const frag = document.createDocumentFragment();
      let last = 0;
      let m;
      while ((m = citeRe.exec(text)) !== null) {
        if (m.index > last) frag.appendChild(document.createTextNode(text.slice(last, m.index)));
        const span = document.createElement('span');
        span.className = 'cite';
        span.textContent = `[${m[1]}]`;
        frag.appendChild(span);
        last = m.index + m[0].length;
      }
      if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
      node.parentNode.replaceChild(frag, node);
    });
    return root.innerHTML;
  }

  function createMarkdownRenderer() {
    if (typeof window.markdownit !== 'function') return null;
    const md = window.markdownit({ html: false, linkify: false, breaks: true });
    const container = window.markdownitContainer;
    if (typeof container === 'function') {
      const addContainer = (name, defaultTitle) => {
        md.use(container, name, {
          render(tokens, idx) {
            const token = tokens[idx];
            if (token.nesting === 1) {
              const info = String(token.info || '').trim();
              const parts = info.split(/\s+/);
              const title = parts.slice(1).join(' ').trim() || defaultTitle;
              return `<div class="admonition ${name}"><div class="admonition-title">${escapeHtml(title)}</div><div class="admonition-body">`;
            }
            return '</div></div>';
          },
        });
      };
      addContainer('tip', 'Tip');
      addContainer('info', 'Info');
      addContainer('warning', 'Warning');
      addContainer('note', 'Note');
    }
    const defaultHeading = md.renderer.rules.heading_open || function (tokens, idx, options, env, self) {
      return self.renderToken(tokens, idx, options);
    };
    md.renderer.rules.heading_open = (tokens, idx, options, env, self) => {
      if (env && env.addHeadingIds) {
        const textToken = tokens[idx + 1];
        if (textToken && textToken.type === 'inline') {
          let id = slugifyId(textToken.content || '');
          const used = env.usedHeadingIds || new Map();
          const count = (used.get(id) || 0) + 1;
          used.set(id, count);
          if (count > 1) id = `${id}-${count}`;
          tokens[idx].attrSet('id', id);
          env.usedHeadingIds = used;
        }
      }
      return defaultHeading(tokens, idx, options, env, self);
    };
    const defaultImage = md.renderer.rules.image || function (tokens, idx, options, env, self) {
      return self.renderToken(tokens, idx, options);
    };
    md.renderer.rules.image = (tokens, idx, options, env, self) => {
      const token = tokens[idx];
      const src = token.attrGet('src');
      const parsed = parseImageWidth(src || '');
      const norm = normalizeUrl(parsed.src || '');
      if (norm) token.attrSet('src', norm);
      applyImageWidthStyle(token, parsed.width);
      token.attrSet('loading', 'lazy');
      return defaultImage(tokens, idx, options, env, self);
    };
    const defaultLink = md.renderer.rules.link_open || function (tokens, idx, options, env, self) {
      return self.renderToken(tokens, idx, options);
    };
    md.renderer.rules.link_open = (tokens, idx, options, env, self) => {
      const token = tokens[idx];
      const href = token.attrGet('href') || '';
      const norm = normalizeUrl(href);
      if (norm) token.attrSet('href', norm);
      token.attrSet('target', '_blank');
      token.attrSet('rel', 'noreferrer');
      return defaultLink(tokens, idx, options, env, self);
    };
    return md;
  }

  const markdownRenderer = createMarkdownRenderer();

  function renderMarkdown(mdText, { addHeadingIds = false } = {}) {
    if (!markdownRenderer) {
      return renderMarkdownFallback(mdText, { addHeadingIds });
    }
    const env = { addHeadingIds: Boolean(addHeadingIds), usedHeadingIds: new Map() };
    const normalized = normalizeAdmonitions(mdText || '');
    let html = markdownRenderer.render(normalized, env);
    html = wrapCitations(html);
    return html;
  }

  function stripYamlQuotes(value) {
    const raw = String(value ?? '').trim();
    if (raw.length >= 2 && raw[0] === raw[raw.length - 1] && (raw[0] === '"' || raw[0] === "'")) {
      return raw.slice(1, -1).trim();
    }
    return raw;
  }

  function parseFrontMatterBlock(markdown) {
    const src = String(markdown || '').replace(/\r\n?/g, '\n');
    if (!src.startsWith('---')) return { meta: {}, body: src, hasFrontMatter: false };
    const lines = src.split('\n');
    if (!lines.length || lines[0].trim() !== '---') return { meta: {}, body: src, hasFrontMatter: false };
    let endIdx = -1;
    for (let i = 1; i < lines.length; i += 1) {
      if (lines[i].trim() === '---') {
        endIdx = i;
        break;
      }
    }
    if (endIdx === -1) return { meta: {}, body: src, hasFrontMatter: false };
    const frontLines = lines.slice(1, endIdx);
    const body = lines.slice(endIdx + 1).join('\n').replace(/^\n+/, '');
    const meta = {};
    let currentKey = null;
    frontLines.forEach((line) => {
      if (!line.trim()) return;
      const top = line.match(/^([A-Za-z0-9_-]+):\s*(.*)$/);
      if (top) {
        const key = top[1];
        const val = top[2].trim();
        if (!val) {
          meta[key] = {};
          currentKey = key;
        } else {
          meta[key] = stripYamlQuotes(val);
          currentKey = null;
        }
        return;
      }
      if (currentKey) {
        const child = line.match(/^\s+([A-Za-z0-9_-]+):\s*(.*)$/);
        if (child) {
          const node = meta[currentKey] && typeof meta[currentKey] === 'object' ? meta[currentKey] : {};
          node[child[1]] = stripYamlQuotes(child[2]);
          meta[currentKey] = node;
        }
      }
    });
    return { meta, body, hasFrontMatter: true };
  }

  function serializeFrontMatter(meta) {
    if (!meta || typeof meta !== 'object' || !Object.keys(meta).length) return '';
    const lines = ['---'];
    const quote = (val) => {
      const raw = String(val ?? '');
      if (!raw) return '';
      if (/[#:\n]/.test(raw) || /^\s|\s$/.test(raw)) {
        return `"${raw.replace(/\"/g, '\\"')}"`;
      }
      return raw;
    };
    Object.keys(meta).forEach((key) => {
      const value = meta[key];
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        lines.push(`${key}:`);
        Object.keys(value).forEach((childKey) => {
          const childVal = value[childKey];
          if (childVal === null || childVal === undefined || String(childVal).trim() === '') return;
          lines.push(`  ${childKey}: ${quote(childVal)}`);
        });
        return;
      }
      if (value === null || value === undefined || String(value).trim() === '') return;
      lines.push(`${key}: ${quote(value)}`);
    });
    lines.push('---');
    return lines.join('\n');
  }

  function extractCoverOverrides(meta) {
    const out = {};
    if (meta?.cover && typeof meta.cover === 'object') {
      Object.keys(meta.cover).forEach((key) => {
        const val = meta.cover[key];
        if (typeof val === 'string' && val.trim()) out[key] = val.trim();
      });
    }
    const mapping = {
      guide_type: 'type',
      cover_type: 'type',
      cover_title: 'title',
      cover_image: 'image',
      cover_text: 'text',
      cover_version: 'version',
      cover_date: 'date',
      cover_copyright: 'copyright',
    };
    Object.keys(mapping).forEach((key) => {
      const val = meta?.[key];
      if (typeof val === 'string' && val.trim()) out[mapping[key]] = val.trim();
    });
    return out;
  }

  function extractHeaderOverrides(meta) {
    const out = {};
    if (meta?.headers && typeof meta.headers === 'object') {
      Object.keys(meta.headers).forEach((key) => {
        const val = meta.headers[key];
        if (typeof val === 'string' && val.trim()) out[key] = val.trim();
      });
    }
    const mapping = {
      header_left: 'left',
      header_right: 'right',
    };
    Object.keys(mapping).forEach((key) => {
      const val = meta?.[key];
      if (typeof val === 'string' && val.trim()) out[mapping[key]] = val.trim();
    });
    return out;
  }

  function buildChunkImageMap(contextChunks) {
	    const map = new Map();
	    if (!Array.isArray(contextChunks)) return map;
	    contextChunks.forEach((chunk) => {
	      const idx = Number(chunk?.index);
	      if (!Number.isFinite(idx)) return;
	      const imgs = Array.isArray(chunk?.images) ? chunk.images.map((x) => String(x || '').trim()).filter(Boolean) : [];
	      if (!imgs.length) return;
	      const headingPath = Array.isArray(chunk?.heading_path) ? chunk.heading_path : [];
	      const heading = headingPath.length ? String(headingPath[headingPath.length - 1]) : '';
	      const scoreVal = Number(chunk?.score);
	      const score = Number.isFinite(scoreVal) ? scoreVal : null;
	      map.set(idx, {
	        images: imgs,
	        heading,
	        doc_id: String(chunk?.doc_id || ''),
	        page_id: String(chunk?.page_id || ''),
	        score
	      });
	    });
	    return map;
	  }

	  function buildImageMetaMap(contextChunks) {
	    const meta = new Map();
	    const byChunk = buildChunkImageMap(contextChunks);
	    byChunk.forEach((info, idx) => {
	      info.images.forEach((url) => {
	        const key = normalizeUrl(url);
	        if (!key || meta.has(key)) return;
	        meta.set(key, {
	          index: idx,
	          heading: info.heading,
	          doc_id: info.doc_id,
	          page_id: info.page_id,
	          score: info.score
	        });
	      });
	    });
	    return meta;
	  }

	  function decorateInlineImages(container, contextChunks) {
	    if (!container) return;
	    const metaByUrl = buildImageMetaMap(contextChunks);
	    if (!metaByUrl.size) return;
	    const imgs = Array.from(container.querySelectorAll('img'));
	    imgs.forEach((img) => {
	      if (img.closest('figure.img-thumb')) return;
	      const src = String(img.getAttribute('src') || img.src || '').trim();
	      if (!src) return;
	      const key = normalizeUrl(src) || src;
	      const meta = metaByUrl.get(key) || metaByUrl.get(src);
	      if (!meta) return;

	      const figure = document.createElement('figure');
	      figure.className = 'img-thumb';
	      const link = document.createElement('a');
	      link.href = key;
	      link.target = '_blank';
	      link.rel = 'noreferrer';

	      const target = img.parentElement && img.parentElement.tagName === 'P' && img.parentElement.childNodes.length === 1
	        ? img.parentElement
	        : img;

	      const imgClone = img.cloneNode(true);
	      link.appendChild(imgClone);
	      figure.appendChild(link);

	      const caption = document.createElement('figcaption');
	      const title = document.createElement('div');
	      title.className = 'img-thumb-title';
	      title.textContent = meta.heading || `${meta.doc_id}/${meta.page_id}`;
	      const stats = document.createElement('div');
	      const parts = [];
	      if (meta.index) parts.push(`chunk #${meta.index}`);
	      if (typeof meta.score === 'number') parts.push(`score ${meta.score.toFixed(3)}`);
	      if (meta.doc_id || meta.page_id) parts.push(`${meta.doc_id}/${meta.page_id}`);
	      stats.textContent = parts.join(' Â· ');
	      caption.appendChild(title);
	      caption.appendChild(stats);
	      figure.appendChild(caption);

	      target.replaceWith(figure);
	    });
	  }

	  function injectTopologicalImages(mdText, contextChunks) {
	    const md = String(mdText || '');
	    if (!md.trim()) return { md, inlined: false };
	    const map = buildChunkImageMap(contextChunks);
	    if (!map.size) return { md, inlined: false };

	    const lines = md.split('\n');
	    const usedUrls = new Set();
	    const usedIndices = new Set();
	    let inserted = false;
	    let inCode = false;
	    let inReferences = false;

	    for (let i = 0; i < lines.length; i++) {
	      const line = lines[i];
	      const trimmed = line.trim();
	      if (trimmed.startsWith('```')) {
	        inCode = !inCode;
	        continue;
	      }
	      if (inCode) continue;

	      const headingMatch = line.match(/^(#{1,6})\s+(.*)$/);
	      if (headingMatch) {
	        const title = String(headingMatch[2] || '').trim().toLowerCase();
	        if (title === 'references') {
	          inReferences = true;
	        }
	      }
	      if (inReferences) continue;

	      const indices = new Set();
	      const citeRe = /\[(\d{1,3})\]/g;
	      let m;
	      while ((m = citeRe.exec(line)) !== null) {
	        const idx = Number(m[1]);
	        if (map.has(idx)) indices.add(idx);
	      }
	      if (!indices.size) continue;

	      const imgLines = [];
	      indices.forEach((idx) => {
	        if (usedIndices.has(idx)) return;
	        const info = map.get(idx);
	        if (!info) return;
	        const base = info.heading || `${info.doc_id}/${info.page_id}`;
	        const caption = base.replace(/\]/g, '').slice(0, 120);
	        const before = imgLines.length;
	        info.images.forEach((url) => {
	          if (!url || usedUrls.has(url)) return;
	          usedUrls.add(url);
	          imgLines.push(`![${caption}](${url})`);
	        });
	        if (imgLines.length > before) {
	          usedIndices.add(idx);
	        }
	      });
	      if (!imgLines.length) continue;

	      lines.splice(i + 1, 0, '', ...imgLines, '');
	      inserted = true;
	      i += imgLines.length + 1;
	    }

	    return { md: lines.join('\n'), inlined: inserted };
	  }

	  function appendMessage({
	    role,
	    content,
	    citations = null,
	    images = null,
	    web_sources = null,
	    context_chunks = null,
	    errorText = null
	  }) {
	    const wrap = document.createElement('div');
	    wrap.className = `msg ${role === 'user' ? 'user' : 'assistant'}`;

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.textContent = role === 'user' ? 'You' : 'Assistant';
    wrap.appendChild(meta);

	    const body = document.createElement('div');
	    body.className = 'content';
	    if (role === 'assistant') {
	      const raw = String(content || '');
	      const hasDocCite = /\[\d{1,3}\]/.test(raw);
	      wrap.dataset.hasDocCite = hasDocCite ? '1' : '0';
	      const augmented = hasDocCite ? injectTopologicalImages(raw, context_chunks) : { md: raw, inlined: false };
	      body.innerHTML = renderMarkdown(augmented.md);
	      decorateInlineImages(body, context_chunks);
	    } else {
	      body.textContent = content || '';
	    }
	    wrap.appendChild(body);

    if (Array.isArray(web_sources) && web_sources.length) {
      const w = document.createElement('div');
      w.className = 'web-sources';
      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = 'Web sources:';
      w.appendChild(title);

      web_sources.forEach((src) => {
        const href = String(src?.final_url || src?.url || '').trim();
        const label = String(src?.title || href || '').trim();

        if (href) {
          const a = document.createElement('a');
          a.href = href;
          a.target = '_blank';
          a.rel = 'noreferrer';
          a.textContent = label || href;
          w.appendChild(a);
        }

        const snippet = String(src?.snippet || '').trim();
        if (snippet) {
          const s = document.createElement('div');
          s.className = 'snippet';
          s.textContent = snippet;
          w.appendChild(s);
        }

        const err = String(src?.error || '').trim();
        if (err) {
          const e = document.createElement('div');
          e.className = 'error';
          e.textContent = err;
          w.appendChild(e);
        }
      });
      wrap.appendChild(w);
    }

    if (wrap.dataset.hasDocCite === '1' && Array.isArray(citations) && citations.length) {
      const c = document.createElement('div');
      c.className = 'citations';
      const seen = new Set();
      citations.forEach((x) => {
        const key = `${x.doc_id}/${x.page_id}/${x.anchor || ''}`;
        if (seen.has(key)) return;
        seen.add(key);
        const a = document.createElement('a');
        a.href = docsHashFor(x.doc_id, x.page_id, x.anchor || null, docsState.version);
        a.textContent = `${x.title} (${x.doc_id}/${x.page_id})`;
	        a.addEventListener('click', (ev) => {
	          if (ev.ctrlKey || ev.metaKey || ev.shiftKey || ev.altKey) return;
	          ev.preventDefault();
	          openDocsReader({
	            doc_id: x.doc_id,
	            page_id: x.page_id,
	            anchor: x.anchor || null,
	            fullscreen: true,
	            version: docsState.version,
	          });
	        });
        c.appendChild(a);
      });
      wrap.appendChild(c);
    }

      if (errorText) {
        const details = document.createElement('details');
        details.className = 'err-details';
        const summary = document.createElement('summary');
        summary.textContent = 'Show raw error';
        const pre = document.createElement('pre');
        pre.textContent = errorText;
        details.appendChild(summary);
        details.appendChild(pre);
        wrap.appendChild(details);
      }

    if (role === 'assistant') {
      const canEditDocs = Boolean(authState?.docs_edit || authState?.role === 'admin');
      if (canEditDocs) {
        const actions = document.createElement('div');
        actions.className = 'actions';
        const editBtn = document.createElement('button');
        editBtn.className = 'btn ghost small';
        editBtn.textContent = 'EDIT IN DOCS';
        editBtn.addEventListener('click', () => {
          openAnswerInDocs({
            content: String(content || ''),
            context_chunks: Array.isArray(context_chunks) ? context_chunks : []
          });
        });
        actions.appendChild(editBtn);
        wrap.appendChild(actions);
      }
    }

	    thread.appendChild(wrap);
	    thread.scrollTop = thread.scrollHeight;
	    setEmptyStateVisible(false);
	    return wrap;
	  }

  async function apiJson(path, { method = 'GET', body = undefined } = {}) {
    const opts = { method, headers: {} };
    if (body !== undefined) {
      if (body instanceof FormData) {
        opts.body = body;
      } else {
        opts.headers['content-type'] = 'application/json';
        opts.body = JSON.stringify(body);
      }
    }
    const resp = await fetch(apiBase + path, opts);
    if (!resp.ok) {
      const text = await resp.text().catch(() => '');
      const err = new Error(`HTTP ${resp.status}`);
      err.status = resp.status;
      err.raw = text;
      throw err;
    }
    return await resp.json();
  }

  async function apiBlob(path, { method = 'GET', body = undefined } = {}) {
    const opts = { method, headers: {} };
    if (body !== undefined) {
      if (body instanceof FormData) {
        opts.body = body;
      } else {
        opts.headers['content-type'] = 'application/json';
        opts.body = JSON.stringify(body);
      }
    }
    const resp = await fetch(apiBase + path, opts);
    if (!resp.ok) {
      const text = await resp.text().catch(() => '');
      const err = new Error(`HTTP ${resp.status}`);
      err.status = resp.status;
      err.raw = text;
      throw err;
    }
    return await resp.blob();
  }

  function downloadBlob(blob, filename) {
    const name = String(filename || 'document.pdf');
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function safeFilename(text) {
    const raw = String(text || '').trim().toLowerCase();
    const cleaned = raw.replace(/[^a-z0-9_-]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    return cleaned || 'document';
  }

	  async function apiSse(path, { body, onEvent, signal } = {}) {
    const opts = { method: 'POST', headers: { accept: 'text/event-stream' } };
    if (body !== undefined) {
      opts.headers['content-type'] = 'application/json';
      opts.body = JSON.stringify(body);
    }
    if (signal) opts.signal = signal;
    const resp = await fetch(apiBase + path, opts);
    if (!resp.ok) {
      const text = await resp.text().catch(() => '');
      const err = new Error(`HTTP ${resp.status}`);
      err.status = resp.status;
      err.raw = text;
      throw err;
    }
    if (!resp.body) {
      throw new Error('No response body for SSE');
    }

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buf = '';

    function flushOne(frame) {
      const raw = String(frame || '').replace(/\r/g, '').trim();
      if (!raw) return;
      let ev = 'message';
      const dataLines = [];
      raw.split('\n').forEach((ln) => {
        const line = String(ln || '').trimEnd();
        if (line.startsWith('event:')) ev = line.slice(6).trim();
        if (line.startsWith('data:')) dataLines.push(line.slice(5).trim());
      });
      const dataStr = dataLines.join('\n');
      let data = dataStr;
      try {
        data = JSON.parse(dataStr);
      } catch (_) {}
      try {
        if (typeof onEvent === 'function') onEvent(ev, data);
      } catch (e) {
        console.error('SSE handler error', e);
      }
    }

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });
      buf = buf.replace(/\r/g, '');
      while (true) {
        const idx = buf.indexOf('\n\n');
        if (idx === -1) break;
        const frame = buf.slice(0, idx);
        buf = buf.slice(idx + 2);
        flushOne(frame);
      }
    }
	    if (buf.trim()) flushOne(buf);
	  }

	  // ---------- Auth ----------
		  let authState = {
		    authenticated: false,
		    role: 'anonymous',
		    user_id: null,
		    username: null,
		    email: null,
		    greeting: null,
		    docs_edit: false,
		    docs_publish: false
		  };

	  function setActionVisible(el, visible) {
	    if (!el) return;
	    el.style.display = visible ? '' : 'none';
	  }

	  function formatUserLabel(a) {
	    if (a && a.authenticated && a.username) return `Logged as ${a.username} (${a.role})`;
	    return 'Anonymous';
	  }

	  function syncGreeting(a) {
	    const g = (a && a.greeting ? String(a.greeting).trim() : '');
	    if (g) {
	      emptyState.textContent = g;
	      return;
	    }
	    if (a && a.authenticated && a.username) {
	      emptyState.textContent = `Hi ${a.username}, I am ready to assist and learn.`;
	      return;
	    }
	    emptyState.textContent = 'Hi, I am ready to assist and learn.';
	  }

		  function applyRoleUI(a) {
		    const role = String(a?.role || 'anonymous');
		    const isAdmin = role === 'admin';
		    const isRedactor = role === 'redactor';
		    const isSupport = role === 'support';
		    const isClient = role === 'client';

		    setActionVisible(toolsBtn, isAdmin);
		    setActionVisible(redactorBtn, isAdmin || isRedactor);
		    setActionVisible(debugBtn, isAdmin || isRedactor || isSupport);
		    setActionVisible(historyBtn, isAdmin || isRedactor || isSupport || isClient);
		    const canEditDocs = Boolean(a?.docs_edit || isAdmin);
		    setActionVisible(docsEditBtn, canEditDocs);
		    setActionVisible(docsPdfBtn, canEditDocs);
		    setActionVisible(docsNewGuideBtn, canEditDocs);
		    setActionVisible(docsNewSectionBtn, canEditDocs);
		    if (docsEditActionsEl) docsEditActionsEl.style.display = canEditDocs ? '' : 'none';
		    if (docsManageActionsEl) docsManageActionsEl.style.display = canEditDocs ? '' : 'none';
        updateDocsManageActions();
		    if (docsStyleCardEl) docsStyleCardEl.style.display = isAdmin ? '' : 'none';

		    if (!isAdmin && adminPanel.classList.contains('visible')) closeAllModals();
		    if (!(isAdmin || isRedactor) && redactorPanel.classList.contains('visible')) closeAllModals();
		    if (!(isAdmin || isRedactor || isSupport) && debugPanel.classList.contains('visible')) closeAllModals();
		    if (!(isAdmin || isRedactor || isSupport || isClient) && historyPanel.classList.contains('visible')) historyPanel.classList.remove('visible');

		    scheduleDockUpdate();
		  }

		  function renderAuthPanel(a) {
		    const role = String(a?.role || 'anonymous');
		    const status = a?.authenticated ? (a.username || 'user') : 'anonymous';
		    if (authStatusEl) authStatusEl.textContent = status;
		    if (authRoleEl) authRoleEl.textContent = role;
		    if (authEmailEl) authEmailEl.textContent = (a?.email ? String(a.email) : 'â€”');

		    const isAuthed = Boolean(a?.authenticated);
		    if (logoutBtnEl) logoutBtnEl.style.display = isAuthed ? '' : 'none';
		    if (loginBtnEl) loginBtnEl.style.display = isAuthed ? 'none' : '';
		    if (loginUsernameEl) loginUsernameEl.disabled = isAuthed;
		    if (loginPasswordEl) loginPasswordEl.disabled = isAuthed;
		    if (pwChangeFormEl) pwChangeFormEl.style.display = isAuthed ? '' : 'none';
		    if (authHintEl) {
		      authHintEl.textContent = isAuthed ? 'Click LOGOUT to switch user.' : 'Enter username/email and password to login.';
		      authHintEl.style.color = 'var(--muted)';
		    }
		  }

	  async function refreshAuth() {
	    try {
	      const me = await apiJson('/auth/me');
	      authState = me;
	    } catch (e) {
		      authState = {
		        authenticated: false,
		        role: 'anonymous',
		        user_id: null,
		        username: null,
		        email: null,
		        greeting: null,
		        docs_edit: false,
		        docs_publish: false
		      };
	    }
	    if (userToggle) userToggle.textContent = formatUserLabel(authState);
	    syncGreeting(authState);
	    renderAuthPanel(authState);
	    applyRoleUI(authState);
	    await loadDocsStyle();
	  }

	  async function doLogin() {
	    if (!loginUsernameEl || !loginPasswordEl || !authHintEl) return;
	    const username = String(loginUsernameEl.value || '').trim();
	    const password = String(loginPasswordEl.value || '');
	    if (!username || !password) {
	      authHintEl.textContent = 'Username and password required.';
	      authHintEl.style.color = 'var(--danger)';
	      return;
	    }
	    authHintEl.textContent = 'Logging inâ€¦';
	    authHintEl.style.color = 'var(--muted)';
	    try {
	      const resp = await apiJson('/auth/login', { method: 'POST', body: { username, password } });
		      authState = resp.user || { authenticated: true, role: 'client', user_id: null, username, email: null, greeting: null };
	      loginPasswordEl.value = '';
	      userSettings.classList.remove('visible');
	      session.session_id = null;
	      await refreshAuth();
	    } catch (e) {
	      const raw = e?.raw ? String(e.raw) : String(e);
	      authHintEl.textContent = raw || 'Login failed.';
	      authHintEl.style.color = 'var(--danger)';
	    }
	  }

		  async function doLogout() {
		    if (authHintEl) {
		      authHintEl.textContent = 'Logging outâ€¦';
		      authHintEl.style.color = 'var(--muted)';
		    }
		    try {
		      await apiJson('/auth/logout', { method: 'POST' });
		    } catch (e) {}
		    session.session_id = null;
		    await refreshAuth();
		  }
		
		  async function doChangePassword() {
		    if (!pwCurrentEl || !pwNewEl || !pwChangeHintEl) return;
		    const current_password = String(pwCurrentEl.value || '');
		    const new_password = String(pwNewEl.value || '');
		    if (!current_password || !new_password) {
		      pwChangeHintEl.textContent = 'Current and new password required.';
		      pwChangeHintEl.style.color = 'var(--danger)';
		      return;
		    }
		    pwChangeHintEl.textContent = 'Updatingâ€¦';
		    pwChangeHintEl.style.color = 'var(--muted)';
		    try {
		      await apiJson('/auth/password/change', { method: 'POST', body: { current_password, new_password } });
		      pwCurrentEl.value = '';
		      pwNewEl.value = '';
		      pwChangeHintEl.textContent = 'Password updated.';
		      pwChangeHintEl.style.color = 'var(--muted)';
		    } catch (e) {
		      const raw = e?.raw ? String(e.raw) : String(e);
		      pwChangeHintEl.textContent = raw || 'Password update failed.';
		      pwChangeHintEl.style.color = 'var(--danger)';
		    }
		  }

	  loginBtnEl?.addEventListener('click', (e) => {
	    e.preventDefault();
	    doLogin();
	  });
		  logoutBtnEl?.addEventListener('click', (e) => {
		    e.preventDefault();
		    doLogout();
		  });
		  pwChangeBtnEl?.addEventListener('click', (e) => {
		    e.preventDefault();
		    doChangePassword();
		  });
	  loginPasswordEl?.addEventListener('keydown', (e) => {
	    if (e.key === 'Enter') {
	      e.preventDefault();
	      doLogin();
	    }
	  });

	  // ---------- Docs reader ----------
  const docsState = {
    catalog: null,
    versions: null,
    version: null,
    selectedDocId: null,
    selectedDocTitle: null,
    pages: [],
    page: null,
    htmlNameToPageId: new Map(),
    searchQuery: '',
    searchPack: null,
    editing: false,
    edit: null,
    editDirty: false,
    navCollapsed: false,
    scrollLock: false,
    frontMatter: null,
    coverOverrides: null,
    headerOverrides: null,
  };

  const DOCS_NAV_STORAGE_KEY = 'luxriot_docs_nav';
  let docsScrollSyncing = false;

  function setDocsStatus(text, { error = false } = {}) {
    if (!docsStatusEl) return;
    docsStatusEl.textContent = String(text || '');
    docsStatusEl.style.color = error ? 'var(--danger)' : 'var(--muted)';
  }

  function setDocsBreadcrumb(text) {
    if (!docsBreadcrumbEl) return;
    docsBreadcrumbEl.textContent = String(text || 'Select a pageâ€¦');
  }

  function docsHashFor(docId, pageId, anchor, version) {
    const p = new URLSearchParams();
    p.set('view', 'docs');
    if (version) p.set('ver', String(version));
    if (docId) p.set('doc', String(docId));
    if (pageId) p.set('page', String(pageId));
    if (anchor) p.set('anchor', String(anchor));
    return `#${p.toString()}`;
  }

  function setDocsNavCollapsed(collapsed, { persist = true } = {}) {
    docsState.navCollapsed = Boolean(collapsed);
    if (docsPanel) docsPanel.classList.toggle('nav-collapsed', docsState.navCollapsed);
    if (docsNavToggleBtn) {
      docsNavToggleBtn.setAttribute('aria-pressed', docsState.navCollapsed ? 'true' : 'false');
    }
    if (persist) {
      try {
        localStorage.setItem(DOCS_NAV_STORAGE_KEY, docsState.navCollapsed ? 'collapsed' : 'expanded');
      } catch (e) {}
    }
  }

  function initDocsNavState() {
    let collapsed = false;
    try {
      collapsed = localStorage.getItem(DOCS_NAV_STORAGE_KEY) === 'collapsed';
    } catch (e) {}
    setDocsNavCollapsed(collapsed, { persist: false });
  }

  function setDocsScrollLock(enabled) {
    docsState.scrollLock = Boolean(enabled);
    if (docsScrollLockBtn) {
      docsScrollLockBtn.classList.toggle('toggled', docsState.scrollLock);
      docsScrollLockBtn.textContent = docsState.scrollLock ? 'UNLOCK SCROLL' : 'LOCK SCROLL';
    }
  }

  function syncDocsScroll(fromEl, toEl) {
    if (!fromEl || !toEl || docsScrollSyncing) return;
    const fromMax = fromEl.scrollHeight - fromEl.clientHeight;
    const toMax = toEl.scrollHeight - toEl.clientHeight;
    const ratio = fromMax > 0 ? fromEl.scrollTop / fromMax : 0;
    docsScrollSyncing = true;
    toEl.scrollTop = ratio * (toMax > 0 ? toMax : 0);
    docsScrollSyncing = false;
  }

	  function parseDocsHash() {
	    const raw = String(location.hash || '').replace(/^#/, '');
	    if (!raw) return null;
	    const p = new URLSearchParams(raw);
	    if (p.get('view') !== 'docs') return null;
	    const docId = (p.get('doc') || '').trim();
	    const pageId = (p.get('page') || '').trim();
	    const anchor = (p.get('anchor') || '').trim();
	    const ver = (p.get('ver') || '').trim();
	    return { doc_id: docId || null, page_id: pageId || null, anchor: anchor || null, version: ver || null };
	  }

	  function _findByIdWithin(container, id) {
	    if (!container) return null;
	    const key = String(id || '').trim();
	    if (!key) return null;
	    const escaped = key.replace(/[^a-zA-Z0-9_-]/g, (m) => `\\${m}`);
	    try {
	      return container.querySelector(`#${escaped}`);
	    } catch (e) {
	      return null;
	    }
	  }

	  function _clearDocsAnchorHighlight() {
	    const prev = docsState?.anchorHighlightEl || null;
	    if (prev && prev.classList) prev.classList.remove('anchor-hit');
	    docsState.anchorHighlightEl = null;
	  }

	  function scrollDocsToAnchor(anchor) {
	    if (!docsPageEl) return;
	    const raw = String(anchor || '').trim();
	    if (!raw || raw === 'pagetitle') {
	      _clearDocsAnchorHighlight();
	      docsPageEl.scrollTop = 0;
	      const h1 = docsPageEl.querySelector('h1');
	      if (h1) {
	        h1.classList.add('anchor-hit');
	        docsState.anchorHighlightEl = h1;
	      }
	      return;
	    }
	    const key = raw.replace(/^#/, '');

	    let el = _findByIdWithin(docsPageEl, key);
	    if (!el) el = _findByIdWithin(docsPageEl, slugifyId(key));
	    if (!el) {
	      const want = slugifyId(key);
	      el =
	        Array.from(docsPageEl.querySelectorAll('h1,h2,h3,h4,h5,h6')).find(
	          (h) => slugifyId(h?.textContent || '') === want
	        ) || null;
	    }
	    if (!el) return;

	    _clearDocsAnchorHighlight();
	    el.classList.add('anchor-hit');
	    docsState.anchorHighlightEl = el;
	    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
	  }

  function normalizeHtmlName(href) {
    let s = String(href || '').trim();
    if (!s) return '';
    s = s.replace(/^[.][\\/]/, '');
    s = s.split('?', 1)[0];
    s = s.split('#', 1)[0];
    s = s.split('/').pop() || s;
    try {
      s = decodeURIComponent(s);
    } catch (_) {}
    return s.trim();
  }

  function renderDocsVersionSelect(versions, selected) {
    if (!docsVersionSelectEl) return;
    docsVersionSelectEl.innerHTML = '';
    (versions || []).forEach((v) => {
      const opt = document.createElement('option');
      opt.value = v;
      opt.textContent = v;
      docsVersionSelectEl.appendChild(opt);
    });
    if (selected && Array.from(docsVersionSelectEl.options).some((o) => o.value === selected)) {
      docsVersionSelectEl.value = selected;
    } else if (docsVersionSelectEl.options.length) {
      docsVersionSelectEl.selectedIndex = 0;
    }
  }

  function resetDocsForVersion(ver) {
    docsState.version = ver;
    docsState.catalog = null;
    docsState.pages = [];
    docsState.page = null;
    docsState.selectedDocId = null;
    docsState.selectedDocTitle = null;
    docsState.htmlNameToPageId = new Map();
    clearDocsSearch({ keepInput: false });
    updateDocsManageActions();
  }

  async function ensureDocsVersions() {
    if (docsState.versions) return docsState.versions;
    const data = await apiJson('/docs/versions');
    const versions = Array.isArray(data?.versions) ? data.versions : [];
    docsState.versions = versions;
    const defaultVer = data?.default_version || null;
    if (!docsState.version) docsState.version = defaultVer || versions[0] || null;
    renderDocsVersionSelect(versions, docsState.version);
    return versions;
  }

  async function ensureDocsCatalog() {
    if (docsState.catalog) return docsState.catalog;
    setDocsStatus('Loading docs catalogâ€¦');
    const ver = docsState.version || null;
    const qs = ver ? `?version=${encodeURIComponent(ver)}` : '';
    const data = await apiJson(`/docs/catalog${qs}`);
    docsState.catalog = data;
    return data;
  }

  function clearDocsSearch({ keepInput = false } = {}) {
    docsState.searchQuery = '';
    docsState.searchPack = null;
    if (docsSearchResultsEl) {
      docsSearchResultsEl.innerHTML = '';
      docsSearchResultsEl.style.display = 'none';
    }
    if (docsSearchInputEl && !keepInput) docsSearchInputEl.value = '';
  }

  function renderDocsSearchResults(pack) {
    if (!docsSearchResultsEl) return;
    docsSearchResultsEl.innerHTML = '';
    const chunks = Array.isArray(pack?.chunks) ? pack.chunks : [];
    if (!chunks.length) {
      docsSearchResultsEl.innerHTML = `<div class="tiny muted">No results.</div>`;
      docsSearchResultsEl.style.display = 'block';
      return;
    }

    const seen = new Set();
    chunks.forEach((ch, idx) => {
      const docId = String(ch.doc_id || '');
      const pageId = String(ch.page_id || '');
      const key = `${docId}/${pageId}/${String(ch.heading_path?.slice(-1)[0] || '')}`;
      if (seen.has(key)) return;
      seen.add(key);

      const item = document.createElement('div');
      item.className = 'docs-item';
      item.style.marginBottom = '10px';

      const top = document.createElement('div');
      top.className = 'top';
      const title = document.createElement('div');
      const hp = Array.isArray(ch.heading_path) ? ch.heading_path : [];
      title.textContent = hp.length ? hp[hp.length - 1] : `${docId}/${pageId}`;
      top.appendChild(title);
      const badge = document.createElement('div');
      badge.className = 'badge score';
      badge.textContent = `#${idx + 1}`;
      top.appendChild(badge);
      item.appendChild(top);

      const sub = document.createElement('div');
      sub.className = 'sub';
      sub.textContent = `${docId}/${pageId}`;
      item.appendChild(sub);

      const snippet = document.createElement('div');
      snippet.className = 'tiny muted';
      const txt = String(ch.text || '').replace(/\s+/g, ' ').trim();
      snippet.textContent = txt.slice(0, 160) + (txt.length > 160 ? 'â€¦' : '');
      snippet.style.marginTop = '6px';
      item.appendChild(snippet);

      item.addEventListener('click', () => {
        if (!docId || !pageId) return;
        if (docsState.selectedDocId === docId) {
          loadAndRenderDocsPage(docId, pageId, null).catch((e) => {
            setDocsStatus(`Failed to load page: ${e?.raw ? String(e.raw) : String(e)}`, { error: true });
          });
        } else {
          openDocsReader({ doc_id: docId, page_id: pageId, anchor: null, version: docsState.version });
        }
      });

      docsSearchResultsEl.appendChild(item);
    });

    docsSearchResultsEl.style.display = 'block';
  }

  async function runDocsSearch(query, { k = 12 } = {}) {
    const q = String(query || '').trim();
    if (!q) {
      clearDocsSearch();
      setDocsStatus('');
      return;
    }
    docsState.searchQuery = q;
    setDocsStatus('Searching docsâ€¦');
    if (docsSearchResultsEl) {
      docsSearchResultsEl.style.display = 'block';
      docsSearchResultsEl.innerHTML = `<div class="tiny muted">Loadingâ€¦</div>`;
    }
    try {
      const kk = Math.max(1, Math.min(25, Number(k || 12)));
      const pack = await apiJson('/docs/search', {
        method: 'POST',
        body: { query: q, k: kk, version: docsState.version || null },
      });
      docsState.searchPack = pack;
      renderDocsSearchResults(pack);
      const found = Array.isArray(pack?.chunks) ? pack.chunks.length : 0;
      setDocsStatus(`Search: ${found} result(s).`);
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Search failed: ${raw}`, { error: true });
      if (docsSearchResultsEl) docsSearchResultsEl.innerHTML = `<div class="tiny muted">Search failed.</div>`;
    }
  }

  function renderDocsGuideSelect(docs, preferredDocId = null) {
    if (!docsGuideSelectEl) return;
    docsGuideSelectEl.innerHTML = '';
    (docs || []).forEach((d) => {
      const opt = document.createElement('option');
      opt.value = d.doc_id;
      opt.textContent = d.doc_title || d.doc_id;
      docsGuideSelectEl.appendChild(opt);
    });
    if (preferredDocId && (docs || []).some((d) => d.doc_id === preferredDocId)) {
      docsGuideSelectEl.value = preferredDocId;
    } else if (docsGuideSelectEl.options.length) {
      docsGuideSelectEl.selectedIndex = 0;
    }
  }

  function getSelectedDocEntry() {
    const docs = Array.isArray(docsState.catalog?.docs) ? docsState.catalog.docs : [];
    const docId = docsState.selectedDocId || docsGuideSelectEl?.value || null;
    if (!docId) return null;
    return docs.find((d) => d.doc_id === docId) || null;
  }

  function updateDocsManageActions() {
    if (!docsManageActionsEl) return;
    const role = String(authState?.role || 'anonymous');
    const isAdmin = role === 'admin';
    const canEditDocs = Boolean(authState?.docs_edit || isAdmin);
    if (!canEditDocs) {
      docsManageActionsEl.style.display = 'none';
      return;
    }
    docsManageActionsEl.style.display = '';
    const entry = getSelectedDocEntry();
    const docId = entry?.doc_id || docsState.selectedDocId || null;
    const docOrigin = String(entry?.origin || 'ingested');
    const ragExcluded = Boolean(entry?.rag_excluded);

    if (docsExcludeToggleEl) {
      docsExcludeToggleEl.checked = ragExcluded;
      docsExcludeToggleEl.disabled = !isAdmin || !docId;
    }
    if (docsExcludeWrapEl) docsExcludeWrapEl.style.opacity = !isAdmin || !docId ? '0.5' : '1';

    let canDeleteGuide = false;
    if (docId && docOrigin === 'custom') {
      if (isAdmin) {
        canDeleteGuide = true;
      } else if (authState?.user_id) {
        const ownerId = String(authState.user_id);
        const pages = Array.isArray(docsState.pages) ? docsState.pages : [];
        if (pages.length) {
          canDeleteGuide = pages.every((p) => p.custom && String(p.author_id || '') === ownerId);
        }
      }
    }

    if (docsDeleteGuideBtn) docsDeleteGuideBtn.disabled = !canDeleteGuide;

    const page = docsState.page || null;
    let canDeletePage = false;
    if (page && page.custom) {
      if (isAdmin) {
        canDeletePage = true;
      } else if (authState?.user_id && String(page.author_id || '') === String(authState.user_id)) {
        canDeletePage = true;
      }
    }
    if (docsDeletePageBtn) docsDeletePageBtn.disabled = !canDeletePage;
  }

  async function loadDocPages(docId) {
    const ver = docsState.version || null;
    const qs = ver ? `?version=${encodeURIComponent(ver)}` : '';
    const data = await apiJson(`/docs/catalog/${encodeURIComponent(docId)}${qs}`);
    docsState.selectedDocId = data.doc_id;
    docsState.selectedDocTitle = data.doc_title;
    docsState.pages = Array.isArray(data.pages) ? data.pages : [];
    docsState.htmlNameToPageId = new Map();
    docsState.pages.forEach((p) => {
      const name = normalizeHtmlName(p.source_path).toLowerCase();
      if (name) docsState.htmlNameToPageId.set(name, p.page_id);
    });
    updateDocsManageActions();
    return data;
  }

  function renderDocsPageList() {
    if (!docsPageListEl) return;
    docsPageListEl.innerHTML = '';
    const pages = docsState.pages || [];
    if (!pages.length) {
      docsPageListEl.innerHTML = `<div class="tiny muted">No pages.</div>`;
      return;
    }
    pages.forEach((p) => {
      const item = document.createElement('div');
      item.className = 'docs-item';
      item.dataset.pageId = p.page_id;

      const depth = Math.max(0, (Array.isArray(p.heading_path) ? p.heading_path.length : 0) - 2);
      item.style.paddingLeft = `${10 + depth * 14}px`;

      const top = document.createElement('div');
      top.className = 'top';
      const title = document.createElement('div');
      title.textContent = p.page_title || p.page_id;
      top.appendChild(title);
      item.appendChild(top);

      const sub = document.createElement('div');
      sub.className = 'sub';
      const hp = Array.isArray(p.heading_path) ? p.heading_path.slice(1).join(' â€º ') : '';
      sub.textContent = hp || `${docsState.selectedDocId}/${p.page_id}`;
      item.appendChild(sub);

      item.addEventListener('click', async () => {
        try {
          await loadAndRenderDocsPage(docsState.selectedDocId, p.page_id, null);
          const hash = docsHashFor(docsState.selectedDocId, p.page_id, null, docsState.version);
          try {
            history.replaceState(null, '', location.pathname + location.search + hash);
          } catch (e) {
            location.hash = hash;
          }
        } catch (e) {
          setDocsStatus(`Failed to load page: ${e?.raw ? String(e.raw) : String(e)}`, { error: true });
        }
      });

      docsPageListEl.appendChild(item);
    });
    highlightDocsActivePage();
  }

  function highlightDocsActivePage() {
    if (!docsPageListEl) return;
    const active = docsState.page?.page_id || null;
    docsPageListEl.querySelectorAll('.docs-item').forEach((el) => {
      const isActive = active && el.dataset.pageId === active;
      el.classList.toggle('active', Boolean(isActive));
    });
  }

	  function wireDocsInternalLinks() {
	    if (!docsPageEl) return;
	    const links = docsPageEl.querySelectorAll('a[href]');
	    links.forEach((a) => {
	      const rawHref = a.getAttribute('href') || '';
	      const href = String(rawHref).trim();
	      if (!href) return;
	      if (href.startsWith('#')) {
	        const anchor = href.slice(1).trim();
	        a.removeAttribute('target');
	        a.removeAttribute('rel');
	        a.addEventListener('click', (ev) => {
	          ev.preventDefault();
	          scrollDocsToAnchor(anchor);
	          const hash = docsHashFor(
	            docsState.selectedDocId,
	            docsState.page?.page_id || null,
	            anchor || null,
	            docsState.version
	          );
	          try {
	            history.replaceState(null, '', location.pathname + location.search + hash);
	          } catch (e) {
	            location.hash = hash;
	          }
	        });
	        return;
	      }
	      if (/^(https?:|data:|blob:)/i.test(href)) return;
	      if (href.startsWith(apiBase)) return;
	      if (href.startsWith('/')) return; // already normalized via normalizeUrl

	      const hrefNoQuery = href.split('?', 1)[0];
	      const parts = hrefNoQuery.split('#', 2);
	      const filePart = normalizeHtmlName(parts[0]);
	      if (!filePart.toLowerCase().endsWith('.html')) return;

	      const pid = docsState.htmlNameToPageId.get(filePart.toLowerCase());
	      if (!pid) return;

	      const anchor = parts.length > 1 ? String(parts[1] || '').trim() : '';
	      a.removeAttribute('target');
	      a.removeAttribute('rel');
	      a.addEventListener('click', (ev) => {
	        ev.preventDefault();
	        openDocsReader({
	          doc_id: docsState.selectedDocId,
	          page_id: pid,
	          anchor: anchor || null,
	          version: docsState.version,
	        });
	      });
	    });
	  }

  function setDocsEditMode(enabled) {
    docsState.editing = Boolean(enabled);
    if (docsContentEl) docsContentEl.classList.toggle('editing', docsState.editing);
    if (!docsState.editing) {
      docsState.edit = null;
      docsState.editDirty = false;
      docsState.frontMatter = null;
      docsState.coverOverrides = null;
      docsState.headerOverrides = null;
      if (docsEditTextEl) docsEditTextEl.value = '';
      if (docsEditPreviewEl) docsEditPreviewEl.innerHTML = '';
      if (docsEditStatusEl) docsEditStatusEl.textContent = '';
      if (docsEditMetaEl) docsEditMetaEl.textContent = 'Edit mode';
    }
  }

  function isFirstDocsPage() {
    const first = Array.isArray(docsState.pages) && docsState.pages.length ? docsState.pages[0].page_id : null;
    return Boolean(first && docsState.page && docsState.page.page_id === first);
  }

  function getCoverDefaults() {
    return {
      type: String(docsStyleState.cover_type || 'Guide'),
      title: String(docsState.selectedDocTitle || docsState.selectedDocId || ''),
      image: String(docsStyleState.cover_image || ''),
      text: String(docsStyleState.cover_text || ''),
      version: String(docsState.version || ''),
      date: '',
      copyright: String(docsStyleState.cover_copyright || ''),
    };
  }

  function updateCoverEditorVisibility() {
    if (!docsCoverEditorEl) return;
    const isFirst = isFirstDocsPage();
    docsCoverEditorEl.classList.toggle('disabled', !isFirst);
  }

  function applyCoverEditorState() {
    updateCoverEditorVisibility();
    const defaults = getCoverDefaults();
    if (docsCoverTypeEditEl) docsCoverTypeEditEl.placeholder = defaults.type || 'Guide';
    if (docsCoverTitleEditEl) docsCoverTitleEditEl.placeholder = defaults.title || 'Auto title';
    if (docsCoverImageEditEl) docsCoverImageEditEl.placeholder = defaults.image || '/assets/...';
    if (docsCoverTextEditEl) docsCoverTextEditEl.placeholder = defaults.text || 'Optional summary';
    if (docsCoverVersionEditEl) docsCoverVersionEditEl.placeholder = defaults.version || 'Auto version';
    if (docsCoverDateEditEl) docsCoverDateEditEl.placeholder = 'Auto date/time';
    if (docsCoverCopyrightEditEl) docsCoverCopyrightEditEl.placeholder = defaults.copyright || 'Â© Luxriot';
    if (docsHeaderLeftEditEl) docsHeaderLeftEditEl.placeholder = 'Auto (guide type)';
    if (docsHeaderRightEditEl) docsHeaderRightEditEl.placeholder = 'Auto (section heading)';

    const overrides = docsState.coverOverrides || {};
    if (docsCoverTypeEditEl) docsCoverTypeEditEl.value = overrides.type || '';
    if (docsCoverTitleEditEl) docsCoverTitleEditEl.value = overrides.title || '';
    if (docsCoverImageEditEl) docsCoverImageEditEl.value = overrides.image || '';
    if (docsCoverTextEditEl) docsCoverTextEditEl.value = overrides.text || '';
    if (docsCoverVersionEditEl) docsCoverVersionEditEl.value = overrides.version || '';
    if (docsCoverDateEditEl) docsCoverDateEditEl.value = overrides.date || '';
    if (docsCoverCopyrightEditEl) docsCoverCopyrightEditEl.value = overrides.copyright || '';
    const headers = docsState.headerOverrides || {};
    if (docsHeaderLeftEditEl) docsHeaderLeftEditEl.value = headers.left || '';
    if (docsHeaderRightEditEl) docsHeaderRightEditEl.value = headers.right || '';
    updateCoverPreview();
  }

  function resolveCoverPreviewValue(val, fallback) {
    const v = String(val || '').trim();
    if (v) return v;
    const f = String(fallback || '').trim();
    return f;
  }

  function updateCoverPreview() {
    if (!docsCoverPreviewEl) return;
    const defaults = getCoverDefaults();
    const overrides = collectCoverOverrides();
    const type = resolveCoverPreviewValue(overrides.type, defaults.type);
    const title = resolveCoverPreviewValue(overrides.title, defaults.title);
    const image = resolveCoverPreviewValue(overrides.image, defaults.image);
    const text = resolveCoverPreviewValue(overrides.text, defaults.text);
    const version = resolveCoverPreviewValue(overrides.version, defaults.version);
    let date = resolveCoverPreviewValue(overrides.date, '');
    if (!date) {
      const now = new Date();
      date = now.toLocaleString();
    }
    const copyright = resolveCoverPreviewValue(overrides.copyright, defaults.copyright);

    if (docsCoverPreviewTypeEl) docsCoverPreviewTypeEl.textContent = type ? type.toUpperCase() : '';
    if (docsCoverPreviewTitleEl) docsCoverPreviewTitleEl.textContent = title || '';
    if (docsCoverPreviewTextEl) docsCoverPreviewTextEl.textContent = text || '';
    if (docsCoverPreviewFooterEl) {
      const parts = [];
      if (version && date) parts.push(`${version} Â· ${date}`);
      else if (version) parts.push(version);
      else if (date) parts.push(date);
      if (copyright) parts.push(copyright);
      docsCoverPreviewFooterEl.textContent = parts.join('\n');
    }

    if (docsCoverPreviewImageEl) {
      docsCoverPreviewImageEl.innerHTML = '';
      if (image) {
        const parsed = parseImageWidth(image);
        const src = normalizeUrl(parsed.src);
        if (src) {
          const img = document.createElement('img');
          img.src = src;
          img.alt = 'Cover';
          docsCoverPreviewImageEl.appendChild(img);
        }
      }
    }
  }

  function collectCoverOverrides() {
    if (!isFirstDocsPage()) return {};
    const take = (el) => String(el?.value || '').trim();
    const overrides = {};
    const type = take(docsCoverTypeEditEl);
    const title = take(docsCoverTitleEditEl);
    const image = take(docsCoverImageEditEl);
    const text = take(docsCoverTextEditEl);
    const version = take(docsCoverVersionEditEl);
    const date = take(docsCoverDateEditEl);
    const copyright = take(docsCoverCopyrightEditEl);
    if (type) overrides.type = type;
    if (title) overrides.title = title;
    if (image) overrides.image = image;
    if (text) overrides.text = text;
    if (version) overrides.version = version;
    if (date) overrides.date = date;
    if (copyright) overrides.copyright = copyright;
    return overrides;
  }

  function collectHeaderOverrides() {
    if (!isFirstDocsPage()) return {};
    const take = (el) => String(el?.value || '').trim();
    const headers = {};
    const left = take(docsHeaderLeftEditEl);
    const right = take(docsHeaderRightEditEl);
    if (left) headers.left = left;
    if (right) headers.right = right;
    return headers;
  }

  function setEditorContent(markdown, { markDirty = false } = {}) {
    const parsed = parseFrontMatterBlock(markdown);
    docsState.frontMatter = parsed.meta || {};
    docsState.coverOverrides = extractCoverOverrides(docsState.frontMatter);
    docsState.headerOverrides = extractHeaderOverrides(docsState.frontMatter);
    if (docsEditTextEl) docsEditTextEl.value = parsed.body || '';
    applyCoverEditorState();
    docsState.editDirty = Boolean(markDirty);
    updateDocsEditPreview();
    updateCoverPreview();
  }

  function composeEditorMarkdown() {
    const body = String(docsEditTextEl?.value || '');
    const meta = Object.assign({}, docsState.frontMatter || {});
    if (isFirstDocsPage()) {
      const overrides = collectCoverOverrides();
      if (Object.keys(overrides).length) {
        meta.cover = overrides;
      } else if (meta.cover) {
        delete meta.cover;
      }
      const headers = collectHeaderOverrides();
      if (Object.keys(headers).length) {
        meta.headers = headers;
      } else if (meta.headers) {
        delete meta.headers;
      }
    }
    const front = serializeFrontMatter(meta);
    if (!front) return body;
    const cleanedBody = body.replace(/^\n+/, '');
    return `${front}\n\n${cleanedBody}`;
  }

  function updateDocsEditPreview() {
    if (!docsEditTextEl || !docsEditPreviewEl) return;
    docsEditPreviewEl.innerHTML = renderMarkdown(docsEditTextEl.value || '', { addHeadingIds: false });
  }

	  function updateDocsEditStatus(edit) {
	    if (!docsEditStatusEl) return;
	    const d = edit?.draft;
	    const p = edit?.published;
	    const r = edit?.publish_request;
	    const dState = d?.updated_at ? `Draft: ${d.updated_at}` : 'Draft: none';
	    const pState = p?.updated_at ? `Published: ${p.updated_at}` : 'Published: none';
	    let rState = 'Request: none';
	    if (r?.status) {
	      const stamp = r?.updated_at ? ` ${r.updated_at}` : '';
	      rState = `Request: ${r.status}${stamp}`;
	    }
	    docsEditStatusEl.textContent = `${dState} Â· ${pState} Â· ${rState}`;
	    if (docsEditSaveDraftBtn) docsEditSaveDraftBtn.disabled = !edit?.can_edit;
	    if (docsEditPublishBtn) {
	      docsEditPublishBtn.disabled = !edit?.can_publish;
	      docsEditPublishBtn.style.display = edit?.can_publish ? '' : 'none';
	    }
	    if (docsEditRequestPublishBtn) {
	      const canReq = Boolean(edit?.can_request_publish);
	      const pending = r?.status === 'pending';
	      docsEditRequestPublishBtn.style.display = canReq ? '' : 'none';
	      docsEditRequestPublishBtn.disabled = !canReq || pending;
	    }
	    if (docsEditDiscardBtn) docsEditDiscardBtn.disabled = !Boolean(edit?.draft);
	    if (docsEditResetPublishedBtn) docsEditResetPublishedBtn.disabled = !Boolean(edit?.published);
	  }

	  async function loadDocsEdit(docId, pageId) {
	    if (!docId || !pageId) return null;
	    if (docsEditStatusEl) docsEditStatusEl.textContent = 'Loading editâ€¦';
	    const ver = docsState.version || null;
	    const qs = ver ? `?version=${encodeURIComponent(ver)}` : '';
	    const edit = await apiJson(
	      `/docs/page/${encodeURIComponent(docId)}/${encodeURIComponent(pageId)}/edit${qs}`
	    );
	    docsState.edit = edit;
	    docsState.editDirty = false;
    const draftText = edit?.draft?.content_md || '';
    const publishedText = edit?.published?.content_md || '';
    const baseText = edit?.base_markdown || '';
    const seed = draftText || publishedText || baseText;
    setEditorContent(seed, { markDirty: false });
    if (docsEditMetaEl) {
      const role = authState?.role ? String(authState.role) : 'anonymous';
      docsEditMetaEl.textContent = `Version: ${edit?.version || 'â€”'} Â· Role: ${role}`;
    }
    updateDocsEditStatus(edit);
    return edit;
  }

	  function insertAtCursor(textarea, text) {
	    if (!textarea) return;
	    const start = textarea.selectionStart ?? textarea.value.length;
	    const end = textarea.selectionEnd ?? textarea.value.length;
	    const before = textarea.value.slice(0, start);
	    const after = textarea.value.slice(end);
	    textarea.value = `${before}${text}${after}`;
	    const pos = start + text.length;
	    textarea.selectionStart = pos;
	    textarea.selectionEnd = pos;
	    textarea.focus();
	    docsState.editDirty = true;
	    updateDocsEditPreview();
	  }

	  function handleInsert(type) {
	    if (!docsEditTextEl) return;
	    switch (type) {
	      case 'h1': insertAtCursor(docsEditTextEl, '# Heading 1\n'); break;
	      case 'h2': insertAtCursor(docsEditTextEl, '## Heading 2\n'); break;
	      case 'h3': insertAtCursor(docsEditTextEl, '### Heading 3\n'); break;
	      case 'h4': insertAtCursor(docsEditTextEl, '#### Heading 4\n'); break;
	      case 'h5': insertAtCursor(docsEditTextEl, '##### Heading 5\n'); break;
	      case 'ul': insertAtCursor(docsEditTextEl, '- Item 1\n- Item 2\n'); break;
	      case 'ol': insertAtCursor(docsEditTextEl, '1. Step one\n2. Step two\n'); break;
	      case 'table':
	        insertAtCursor(docsEditTextEl, '| Column | Column |\n| --- | --- |\n| Value | Value |\n');
	        break;
	      case 'tip':
	        insertAtCursor(docsEditTextEl, '> [!TIP] Tip\n> Add your tip here.\n');
	        break;
	      case 'warn':
	        insertAtCursor(docsEditTextEl, '> [!WARNING] Warning\n> Add your warning here.\n');
	        break;
	      case 'info':
	        insertAtCursor(docsEditTextEl, '> [!INFO] Info\n> Add your note here.\n');
	        break;
	      default:
	        break;
	    }
	  }

	  docsEditorEl?.addEventListener('click', (e) => {
	    const target = e.target;
	    if (!(target instanceof HTMLElement)) return;
	    const btn = target.closest('[data-insert]');
	    if (!btn) return;
	    const type = btn.getAttribute('data-insert');
	    if (type) handleInsert(type);
	  });

  docsEditTextEl?.addEventListener('input', () => {
    docsState.editDirty = true;
    updateDocsEditPreview();
  });
  const coverInputs = [
    docsCoverTypeEditEl,
    docsCoverTitleEditEl,
    docsCoverImageEditEl,
    docsCoverTextEditEl,
    docsCoverVersionEditEl,
    docsCoverDateEditEl,
    docsCoverCopyrightEditEl,
    docsHeaderLeftEditEl,
    docsHeaderRightEditEl,
  ];
  coverInputs.forEach((el) => {
    el?.addEventListener('input', () => {
      docsState.editDirty = true;
      updateCoverPreview();
    });
  });
	  docsEditTextEl?.addEventListener('scroll', () => {
	    if (!docsState.scrollLock) return;
	    syncDocsScroll(docsEditTextEl, docsEditPreviewEl);
	  });
	  docsEditPreviewEl?.addEventListener('scroll', () => {
	    if (!docsState.scrollLock) return;
	    syncDocsScroll(docsEditPreviewEl, docsEditTextEl);
	  });

  async function saveDocsEdit(status) {
    const page = docsState.page;
    if (!page || !docsEditTextEl) return;
    const content = composeEditorMarkdown();
    if (!content.trim()) {
      if (docsEditStatusEl) docsEditStatusEl.textContent = 'Content is empty.';
      return;
    }
	    if (docsEditStatusEl) docsEditStatusEl.textContent = status === 'published' ? 'Publishingâ€¦' : 'Saving draftâ€¦';
	    try {
      const payload = { content, status, version: docsState.version || null };
	      const edit = await apiJson(`/docs/page/${encodeURIComponent(page.doc_id)}/${encodeURIComponent(page.page_id)}/edit`, {
	        method: 'POST',
	        body: payload,
	      });
	      docsState.edit = edit;
	      docsState.editDirty = false;
	      updateDocsEditStatus(edit);
	      updateDocsEditPreview();
	      if (status === 'published') {
	        await loadAndRenderDocsPage(page.doc_id, page.page_id, null);
	      }
	    } catch (e) {
	      const raw = e?.raw ? String(e.raw) : String(e);
	      if (docsEditStatusEl) docsEditStatusEl.textContent = `Save failed: ${raw}`;
	    }
	  }

	  async function discardDocsDraft() {
	    const page = docsState.page;
	    if (!page) return;
	    if (!confirm('Discard the current draft?')) return;
	    if (docsEditStatusEl) docsEditStatusEl.textContent = 'Discarding draftâ€¦';
    try {
      const edit = await apiJson(
        `/docs/page/${encodeURIComponent(page.doc_id)}/${encodeURIComponent(page.page_id)}/edit/delete`,
        { method: 'POST', body: { status: 'draft', version: docsState.version || null } }
      );
      docsState.edit = edit;
      docsState.editDirty = false;
      const publishedText = edit?.published?.content_md || '';
      const baseText = edit?.base_markdown || '';
      setEditorContent(publishedText || baseText, { markDirty: false });
      updateDocsEditStatus(edit);
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      if (docsEditStatusEl) docsEditStatusEl.textContent = `Discard failed: ${raw}`;
    }
	  }

	  docsEditSaveDraftBtn?.addEventListener('click', () => saveDocsEdit('draft'));
	  docsEditPublishBtn?.addEventListener('click', () => saveDocsEdit('published'));
	  async function requestDocsPublish() {
	    const page = docsState.page;
	    if (!page || !docsEditTextEl) return;
	    const content = composeEditorMarkdown();
	    if (!content.trim()) {
	      if (docsEditStatusEl) docsEditStatusEl.textContent = 'Content is empty.';
	      return;
	    }
	    if (docsEditStatusEl) docsEditStatusEl.textContent = 'Requesting publishâ€¦';
	    try {
	      const edit = await apiJson(
	        `/docs/page/${encodeURIComponent(page.doc_id)}/${encodeURIComponent(page.page_id)}/publish/request`,
	        { method: 'POST', body: { content, version: docsState.version || null } }
	      );
	      docsState.edit = edit;
	      docsState.editDirty = false;
	      updateDocsEditStatus(edit);
	      updateDocsEditPreview();
	    } catch (e) {
	      const raw = e?.raw ? String(e.raw) : String(e);
	      if (docsEditStatusEl) docsEditStatusEl.textContent = `Publish request failed: ${raw}`;
	    }
	  }
	  docsEditRequestPublishBtn?.addEventListener('click', () => requestDocsPublish());
	  docsEditDiscardBtn?.addEventListener('click', () => discardDocsDraft());
  docsEditResetBaseBtn?.addEventListener('click', () => {
    const base = docsState.edit?.base_markdown || '';
    setEditorContent(base, { markDirty: true });
  });
  docsEditResetPublishedBtn?.addEventListener('click', () => {
    const published = docsState.edit?.published?.content_md || '';
    if (!published) return;
    setEditorContent(published, { markDirty: true });
  });

	  docsInsertLinkBtn?.addEventListener('click', () => {
	    if (!docsEditTextEl) return;
	    const href = prompt('Link URL (https://...)', '');
	    if (!href) return;
	    const label = prompt('Link label', href) || href;
	    insertAtCursor(docsEditTextEl, `[${label}](${href})`);
	  });

	  docsInsertImageBtn?.addEventListener('click', () => {
	    if (docsImageInputEl) docsImageInputEl.click();
	  });

	  docsImageInputEl?.addEventListener('change', async () => {
	    const files = docsImageInputEl.files;
	    if (!files || !files.length) return;
	    const page = docsState.page;
	    if (!page) return;
	    const file = files[0];
	    const form = new FormData();
	    form.append('file', file);
	    form.append('doc_id', String(page.doc_id || ''));
	    form.append('page_id', String(page.page_id || ''));
	    if (docsState.version) form.append('version', String(docsState.version));
	    if (docsEditStatusEl) docsEditStatusEl.textContent = 'Uploading imageâ€¦';
	    try {
	      const res = await apiJson('/docs/assets/upload', { method: 'POST', body: form });
	      const url = res?.url ? String(res.url) : '';
	      if (url) {
	        insertAtCursor(docsEditTextEl, `![screenshot](${url})\n`);
	      }
	      if (docsEditStatusEl) docsEditStatusEl.textContent = 'Image uploaded.';
	    } catch (e) {
	      const raw = e?.raw ? String(e.raw) : String(e);
	      if (docsEditStatusEl) docsEditStatusEl.textContent = `Upload failed: ${raw}`;
	    } finally {
	      docsImageInputEl.value = '';
	    }
	  });

	  async function loadAndRenderDocsPage(docId, pageId, anchor = null) {
	    if (docsState.editing && docsState.editDirty) {
	      const ok = confirm('You have unsaved edits. Discard and load another page?');
	      if (!ok) return;
	      setDocsEditMode(false);
	    }
	    setDocsStatus('Loading pageâ€¦');
	    const ver = docsState.version || null;
	    const qs = ver ? `?version=${encodeURIComponent(ver)}` : '';
	    const page = await apiJson(`/docs/page/${encodeURIComponent(docId)}/${encodeURIComponent(pageId)}${qs}`);
	    docsState.page = page;
	    docsState.selectedDocId = page.doc_id;
	    docsState.selectedDocTitle = page.doc_title;
	    setDocsBreadcrumb(`${page.doc_title} â€º ${page.page_title}`);

    if (docsPageEl) {
      docsPageEl.innerHTML = renderMarkdown(page.markdown || '', { addHeadingIds: true });
      wireDocsInternalLinks();
      if (anchor) {
        scrollDocsToAnchor(anchor);
      } else {
        _clearDocsAnchorHighlight();
        docsPageEl.scrollTop = 0;
      }
    }
    setDocsStatus('');
    highlightDocsActivePage();
    updateDocsManageActions();
  }

  async function openDocsReader({ doc_id = null, page_id = null, anchor = null, fullscreen = null, version = null } = {}) {
		    openModal(docsPanel);
		    setDocsEditMode(false);
		    loadDocsStyle().catch(() => {});
		    if (fullscreen === true) setDocsFullscreen(true);
		    if (fullscreen === false) setDocsFullscreen(false);
		    setDocsStatus('');
	    // Keep prior search results, but don't auto-run.

    try {
      await ensureDocsVersions();
      if (version && version !== docsState.version) resetDocsForVersion(version);
      if (docsVersionSelectEl && docsState.version) docsVersionSelectEl.value = docsState.version;
      const catalog = await ensureDocsCatalog();
      const docs = Array.isArray(catalog?.docs) ? catalog.docs : [];
      renderDocsGuideSelect(docs, doc_id);
      const selectedDocId = doc_id || docsGuideSelectEl?.value || (docs[0]?.doc_id ?? null);
      if (!selectedDocId) {
        setDocsStatus('No docs found. Run ingestion to create datastore.', { error: true });
        return;
      }
      await loadDocPages(selectedDocId);
      renderDocsPageList();

      // If search is active, keep the results visible.
      if (docsState.searchQuery) {
        if (docsSearchInputEl) docsSearchInputEl.value = docsState.searchQuery;
        if (docsState.searchPack) renderDocsSearchResults(docsState.searchPack);
      }

      let desiredPage = page_id || null;
      if (!desiredPage && docsState.page?.doc_id === selectedDocId) desiredPage = docsState.page.page_id;
      if (!desiredPage && Array.isArray(docsState.pages) && docsState.pages.length) desiredPage = docsState.pages[0].page_id;
      if (desiredPage) {
        await loadAndRenderDocsPage(selectedDocId, desiredPage, anchor);
      } else {
        setDocsBreadcrumb(`${docsState.selectedDocTitle} â€º Select a pageâ€¦`);
        if (docsPageEl) docsPageEl.innerHTML = '';
      }

      const hash = docsHashFor(selectedDocId, desiredPage, anchor, docsState.version);
      if (location.hash !== hash) {
        try {
          history.replaceState(null, '', location.pathname + location.search + hash);
        } catch (e) {
          location.hash = hash;
        }
      }
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Failed to load docs: ${raw}`, { error: true });
    }
  }

  function suggestTitleFromAnswer(text) {
    const raw = String(text || '').trim();
    if (!raw) return 'New guide';
    const lines = raw.split('\n').map((l) => l.trim()).filter(Boolean);
    for (const line of lines) {
      const heading = line.match(/^#{1,6}\s+(.*)$/);
      if (heading) return heading[1].trim() || 'New guide';
    }
    for (const line of lines) {
      if (/^based on/i.test(line)) continue;
      const cleaned = line.replace(/\[[^\]]+\]/g, '').trim();
      if (cleaned) return cleaned.slice(0, 80);
    }
    return 'New guide';
  }

  async function startDocsEditForPage(docId, pageId, seedMarkdown) {
    if (!docId || !pageId) return;
    setDocsEditMode(true);
    await loadDocsEdit(docId, pageId);
    const seed = String(seedMarkdown || '').trim();
    if (seed) {
      setEditorContent(seed, { markDirty: true });
      if (docsEditStatusEl) docsEditStatusEl.textContent = 'Draft: unsaved Â· Published: none';
    }
  }

  async function openAnswerInDocs({ content, context_chunks } = {}) {
    const canEditDocs = Boolean(authState?.docs_edit || authState?.role === 'admin');
    if (!canEditDocs) return;
    const raw = String(content || '').trim();
    if (!raw) return;
    if (docsState.editing && docsState.editDirty) {
      const ok = confirm('You have unsaved edits. Discard and open this answer in docs?');
      if (!ok) return;
      setDocsEditMode(false);
    }
    const selectedDoc = docsState.selectedDocId || null;
    await openDocsReader({ version: docsState.version || null, doc_id: selectedDoc });

    const augmented = injectTopologicalImages(raw, context_chunks);
    const seedMarkdown = augmented.md || raw;
    const suggestion = suggestTitleFromAnswer(raw);
    const currentTitle = docsState.selectedDocTitle || docsState.selectedDocId || '';
    let useSection = false;
    if (currentTitle) {
      useSection = confirm(`Add as new section to "${currentTitle}"?`);
    }
    if (useSection) {
      const title = prompt('New section title', suggestion) || '';
      if (!title.trim()) return;
      await createNewSection({ title: title.trim(), seedMarkdown });
    } else {
      const title = prompt('New guide name', suggestion) || '';
      if (!title.trim()) return;
      await createNewGuide({ title: title.trim(), seedMarkdown });
    }
  }

  docsGuideSelectEl?.addEventListener('change', async () => {
    const docId = docsGuideSelectEl.value;
    if (!docId) return;
    if (docsState.editing && docsState.editDirty) {
      if (!confirm('You have unsaved edits. Discard and switch guide?')) {
        docsGuideSelectEl.value = docsState.selectedDocId || '';
        return;
      }
      setDocsEditMode(false);
    }
    try {
      await loadDocPages(docId);
      docsState.page = null;
	      renderDocsPageList();
	      setDocsBreadcrumb(`${docsState.selectedDocTitle} â€º Select a pageâ€¦`);
	      if (docsPageEl) docsPageEl.innerHTML = '';
	      const hash = docsHashFor(docId, null, null, docsState.version);
      try {
        history.replaceState(null, '', location.pathname + location.search + hash);
      } catch (e) {
        location.hash = hash;
      }
      setDocsStatus('');
    } catch (e) {
      setDocsStatus(`Failed to load guide: ${e?.raw ? String(e.raw) : String(e)}`, { error: true });
	    }
	  });

  docsExcludeToggleEl?.addEventListener('change', async () => {
    const docId = docsState.selectedDocId || null;
    if (!docId) return;
    const desired = Boolean(docsExcludeToggleEl?.checked);
    try {
      await apiJson(`/docs/guide/${encodeURIComponent(docId)}/exclude`, {
        method: 'POST',
        body: { version: docsState.version || null, excluded: desired },
      });
      if (docsState.catalog && Array.isArray(docsState.catalog.docs)) {
        const entry = docsState.catalog.docs.find((d) => d.doc_id === docId);
        if (entry) entry.rag_excluded = desired;
      }
      updateDocsManageActions();
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Exclude update failed: ${raw}`, { error: true });
      if (docsExcludeToggleEl) docsExcludeToggleEl.checked = !desired;
    }
  });

  docsDeleteGuideBtn?.addEventListener('click', async () => {
    const docId = docsState.selectedDocId || null;
    if (!docId) return;
    if (!confirm(`Delete guide "${docsState.selectedDocTitle || docId}"? This cannot be undone.`)) return;
    setDocsStatus('Deleting guideâ€¦');
    try {
      await apiJson(`/docs/guide/${encodeURIComponent(docId)}/delete`, {
        method: 'POST',
        body: { version: docsState.version || null },
      });
      docsState.catalog = null;
      docsState.pages = [];
      docsState.page = null;
      docsState.selectedDocId = null;
      docsState.selectedDocTitle = null;
      await ensureDocsCatalog();
      const docs = Array.isArray(docsState.catalog?.docs) ? docsState.catalog.docs : [];
      renderDocsGuideSelect(docs, null);
      if (docs.length) {
        const nextDoc = docsGuideSelectEl?.value || docs[0].doc_id;
        await loadDocPages(nextDoc);
        renderDocsPageList();
        if (docsState.pages.length) {
          await loadAndRenderDocsPage(nextDoc, docsState.pages[0].page_id, null);
        } else {
          setDocsBreadcrumb(`${docsState.selectedDocTitle} â€º Select a pageâ€¦`);
          if (docsPageEl) docsPageEl.innerHTML = '';
        }
      } else {
        setDocsBreadcrumb('Select a pageâ€¦');
        if (docsPageEl) docsPageEl.innerHTML = '';
      }
      setDocsStatus('');
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Delete failed: ${raw}`, { error: true });
    }
  });

  docsDeletePageBtn?.addEventListener('click', async () => {
    const page = docsState.page || null;
    if (!page) return;
    if (!confirm(`Delete page "${page.page_title || page.page_id}"? This cannot be undone.`)) return;
    setDocsStatus('Deleting pageâ€¦');
    try {
      await apiJson(`/docs/page/${encodeURIComponent(page.doc_id)}/${encodeURIComponent(page.page_id)}/delete`, {
        method: 'POST',
        body: { version: docsState.version || null },
      });
      await loadDocPages(page.doc_id);
      renderDocsPageList();
      if (docsState.pages.length) {
        await loadAndRenderDocsPage(page.doc_id, docsState.pages[0].page_id, null);
      } else {
        docsState.page = null;
        if (docsPageEl) docsPageEl.innerHTML = '';
        setDocsBreadcrumb(`${docsState.selectedDocTitle} â€º Select a pageâ€¦`);
      }
      setDocsStatus('');
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Delete failed: ${raw}`, { error: true });
    }
  });

  docsVersionSelectEl?.addEventListener('change', async () => {
    const nextVer = docsVersionSelectEl.value;
    if (!nextVer || nextVer === docsState.version) return;
    if (docsState.editing && docsState.editDirty) {
      if (!confirm('You have unsaved edits. Discard and switch version?')) {
        docsVersionSelectEl.value = docsState.version || '';
        return;
      }
      setDocsEditMode(false);
    }
    resetDocsForVersion(nextVer);
    try {
      await openDocsReader({ version: nextVer, doc_id: null, page_id: null, anchor: null });
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Failed to switch version: ${raw}`, { error: true });
    }
  });

  async function createNewGuide() {
    const opts = arguments.length > 0 ? arguments[0] : {};
    const providedTitle = opts && typeof opts === 'object' ? String(opts.title || '').trim() : '';
    const seedMarkdown = opts && typeof opts === 'object' ? String(opts.seedMarkdown || '').trim() : '';
    if (!docsState.version) {
      setDocsStatus('Select a docs version first.', { error: true });
      return;
    }
    if (docsState.editing && docsState.editDirty) {
      if (!confirm('You have unsaved edits. Discard and create a new guide?')) return;
      setDocsEditMode(false);
    }
    const title = providedTitle || prompt('New guide name', '');
    if (!title) return;
    setDocsStatus('Creating guideâ€¦');
    try {
      const res = await apiJson('/docs/guide', {
        method: 'POST',
        body: { doc_title: title, version: docsState.version },
      });
      docsState.catalog = null;
      await openDocsReader({ version: docsState.version, doc_id: res.doc_id, page_id: res.page_id, anchor: null });
      await startDocsEditForPage(res.doc_id, res.page_id, seedMarkdown);
      setDocsStatus('Guide created.');
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Create guide failed: ${raw}`, { error: true });
    }
  }

  async function createNewSection() {
    const opts = arguments.length > 0 ? arguments[0] : {};
    const providedTitle = opts && typeof opts === 'object' ? String(opts.title || '').trim() : '';
    const seedMarkdown = opts && typeof opts === 'object' ? String(opts.seedMarkdown || '').trim() : '';
    if (!docsState.version) {
      setDocsStatus('Select a docs version first.', { error: true });
      return;
    }
    const docId = docsState.selectedDocId;
    if (!docId) {
      setDocsStatus('Select a guide first.', { error: true });
      return;
    }
    if (docsState.editing && docsState.editDirty) {
      if (!confirm('You have unsaved edits. Discard and create a new section?')) return;
      setDocsEditMode(false);
    }
    const title = providedTitle || prompt('New section title', '');
    if (!title) return;
    setDocsStatus('Creating sectionâ€¦');
    try {
      const res = await apiJson('/docs/section', {
        method: 'POST',
        body: { doc_id: docId, page_title: title, version: docsState.version },
      });
      docsState.catalog = null;
      await loadDocPages(docId);
      renderDocsPageList();
      await loadAndRenderDocsPage(docId, res.page_id, null);
      await startDocsEditForPage(docId, res.page_id, seedMarkdown);
      setDocsStatus('Section created.');
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`Create section failed: ${raw}`, { error: true });
    }
  }

  docsNewGuideBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    createNewGuide();
  });
  docsNewSectionBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    createNewSection();
  });

	  docsSearchBtn?.addEventListener('click', () => runDocsSearch(docsSearchInputEl?.value, { k: 12 }));
	  docsSearchClearBtn?.addEventListener('click', () => {
	    clearDocsSearch();
	    setDocsStatus('');
	  });
  docsHeadingFontEl?.addEventListener('change', () => saveDocsStyle());
  docsBodyFontEl?.addEventListener('change', () => saveDocsStyle());
  docsCoverTypeEl?.addEventListener('change', () => saveDocsStyle());
  docsCoverImageEl?.addEventListener('change', () => saveDocsStyle());
  docsCoverTextEl?.addEventListener('change', () => saveDocsStyle());
  docsCoverCopyrightEl?.addEventListener('change', () => saveDocsStyle());
  docsCoverResetBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    if (!isFirstDocsPage()) return;
    docsState.coverOverrides = {};
    docsState.headerOverrides = {};
    if (docsCoverTypeEditEl) docsCoverTypeEditEl.value = '';
    if (docsCoverTitleEditEl) docsCoverTitleEditEl.value = '';
    if (docsCoverImageEditEl) docsCoverImageEditEl.value = '';
    if (docsCoverTextEditEl) docsCoverTextEditEl.value = '';
    if (docsCoverVersionEditEl) docsCoverVersionEditEl.value = '';
    if (docsCoverDateEditEl) docsCoverDateEditEl.value = '';
    if (docsCoverCopyrightEditEl) docsCoverCopyrightEditEl.value = '';
    if (docsHeaderLeftEditEl) docsHeaderLeftEditEl.value = '';
    if (docsHeaderRightEditEl) docsHeaderRightEditEl.value = '';
    applyCoverEditorState();
    docsState.editDirty = true;
  });
  docsCoverGoFirstBtn?.addEventListener('click', (e) => {
    e.preventDefault();
    const first = Array.isArray(docsState.pages) && docsState.pages.length ? docsState.pages[0] : null;
    if (!first || !first.page_id || !docsState.selectedDocId) return;
    if (docsState.editing && docsState.editDirty) {
      if (!confirm('You have unsaved edits. Discard and open the first page?')) return;
      setDocsEditMode(false);
    }
    openDocsReader({
      doc_id: docsState.selectedDocId,
      page_id: first.page_id,
      version: docsState.version || null,
    });
  });
	  docsNavToggleBtn?.addEventListener('click', () => setDocsNavCollapsed(!docsState.navCollapsed));
	  docsScrollLockBtn?.addEventListener('click', () => setDocsScrollLock(!docsState.scrollLock));
  docsSearchInputEl?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      runDocsSearch(docsSearchInputEl.value, { k: 12 });
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      clearDocsSearch();
      setDocsStatus('');
    }
  });

  async function downloadDocsPdf() {
    const canEditDocs = Boolean(authState?.docs_edit || authState?.role === 'admin');
    if (!canEditDocs) return;
    if (docsState.editing && docsEditTextEl) {
      const markdown = String(composeEditorMarkdown() || '').trim();
      if (!markdown) {
        setDocsStatus('Nothing to export.', { error: true });
        return;
      }
      const title = docsState.page?.page_title || docsState.selectedDocTitle || 'draft';
      setDocsStatus('Building PDFâ€¦');
      try {
        const blob = await apiBlob('/docs/pdf', {
          method: 'POST',
          body: { markdown, title, version: docsState.version || null },
        });
        downloadBlob(blob, `${safeFilename(title)}.pdf`);
        setDocsStatus('PDF downloaded.');
      } catch (e) {
        const raw = e?.raw ? String(e.raw) : String(e);
        setDocsStatus(`PDF export failed: ${raw}`, { error: true });
      }
      return;
    }

    const docId = docsState.selectedDocId;
    if (!docId) {
      setDocsStatus('Select a guide first.', { error: true });
      return;
    }
    const ver = docsState.version || null;
    const qs = ver ? `?version=${encodeURIComponent(ver)}` : '';
    setDocsStatus('Building PDFâ€¦');
    try {
      const blob = await apiBlob(`/docs/guide/${encodeURIComponent(docId)}/pdf${qs}`);
      const title = docsState.selectedDocTitle || docId;
      downloadBlob(blob, `${safeFilename(title)}.pdf`);
      setDocsStatus('PDF downloaded.');
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDocsStatus(`PDF export failed: ${raw}`, { error: true });
    }
  }

	  function setDocsFullscreen(enabled) {
	    const on = Boolean(enabled);
	    docsPanel.classList.toggle('fullscreen', on);
	    if (docsFullscreenBtn) {
	      docsFullscreenBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
	    }
	  }

  docsFullscreenBtn?.addEventListener('click', () => {
    setDocsFullscreen(!docsPanel.classList.contains('fullscreen'));
  });

	  function setDocsTheme(theme) {
	    const t = String(theme || '').toLowerCase() === 'light' ? 'light' : 'dark';
	    docsPanel.classList.toggle('light', t === 'light');
	    if (docsThemeBtn) docsThemeBtn.setAttribute('aria-pressed', t === 'light' ? 'true' : 'false');
	    try {
	      localStorage.setItem('luxriot_docs_theme', t);
	    } catch (e) {}
	  }

  docsThemeBtn?.addEventListener('click', () => {
    setDocsTheme(docsPanel.classList.contains('light') ? 'dark' : 'light');
  });

  // ---------- Retrieval debug ----------
  function setDebugStatus(text, { error = false } = {}) {
    if (!debugStatusEl) return;
    debugStatusEl.textContent = String(text || '');
    debugStatusEl.style.color = error ? 'var(--danger)' : 'var(--muted)';
  }

  function fmt(n, digits = 4) {
    const x = Number(n);
    if (!Number.isFinite(x)) return 'â€”';
    return x.toFixed(digits);
  }

  function renderRetrievalDebug(pack) {
    if (!debugResultsEl) return;
    debugResultsEl.innerHTML = '';

    if (debugRawEl) debugRawEl.textContent = JSON.stringify(pack || null, null, 2);
    if (debugSettingsEl) {
      debugSettingsEl.textContent = JSON.stringify(
        { retrieval: adminBundle?.effective?.retrieval || null, llm: adminBundle?.effective?.llm || null },
        null,
        2
      );
    }

    const dbg = pack?.debug;
    if (!dbg) {
      debugResultsEl.innerHTML = `<div class="tiny muted">No debug info returned. Run with debug enabled.</div>`;
      return;
    }

    const chunks = Array.isArray(pack?.chunks) ? pack.chunks : [];
    const selected = Array.isArray(dbg?.selected) ? dbg.selected : [];
    const mmrTrace = Array.isArray(dbg?.mmr_trace) ? dbg.mmr_trace : [];
    const mmrById = new Map();
    mmrTrace.forEach((t) => { if (t?.chunk_id) mmrById.set(String(t.chunk_id), t); });

    setDebugStatus(
      `mode=${dbg.mode} k=${dbg.k} candidates=${dbg.candidates_count ?? 'â€”'} mmr=${dbg?.mmr?.enabled ? 'on' : 'off'} expand=${dbg?.expand?.neighbors || 0}`,
      { error: false }
    );

    selected.forEach((s, idx) => {
      const row = document.createElement('div');
      row.className = 'debug-row';

      const top = document.createElement('div');
      top.className = 'top';
      const title = document.createElement('div');
      const label = s?.page_id ? `${s.doc_id}/${s.page_id}` : (s?.chunk_id || `#${idx + 1}`);
      title.textContent = `#${s?.rank ?? (idx + 1)} ${label}`;
      top.appendChild(title);

      const open = document.createElement('button');
      open.className = 'btn ghost small';
      open.textContent = 'OPEN';
      open.addEventListener('click', () => {
        if (!s?.doc_id || !s?.page_id) return;
        openDocsReader({ doc_id: s.doc_id, page_id: s.page_id, anchor: null, version: docsState.version });
      });
      top.appendChild(open);
      row.appendChild(top);

      const kv = document.createElement('div');
      kv.className = 'debug-kv';

      const parts = [];
      parts.push(`<span class="k">score</span>=${fmt(s?.returned_score ?? s?.score, 6)}`);
      if (s?.rrf_base !== undefined) parts.push(`<span class="k">rrf</span>=${fmt(s.rrf_base, 6)}`);
      if (s?.bm25?.rank) parts.push(`<span class="k">bm25</span>#${s.bm25.rank} (${fmt(s?.bm25?.score, 4)})`);
      if (s?.embedding?.rank) parts.push(`<span class="k">emb</span>#${s.embedding.rank} (${fmt(s?.embedding?.score, 4)})`);
      if (s?.doc_priority_mult) parts.push(`<span class="k">docÃ—</span>${fmt(s.doc_priority_mult, 3)}`);
      if (s?.heading_mult) parts.push(`<span class="k">headÃ—</span>${fmt(s.heading_mult, 3)}`);

      const mmr = s?.chunk_id ? mmrById.get(String(s.chunk_id)) : null;
      if (mmr) {
        parts.push(`<span class="k">mmr</span>@${mmr.step} rel=${fmt(mmr.relevance, 3)} sim=${fmt(mmr.max_similarity, 3)} mmr=${fmt(mmr.mmr_score, 3)}`);
      }
      kv.innerHTML = parts.join(' Â· ');
      row.appendChild(kv);

      const chunk = chunks[idx];
      if (chunk?.text) {
        const details = document.createElement('details');
        details.className = 'err-details';
        const sum = document.createElement('summary');
        sum.textContent = 'Show chunk text';
        const pre = document.createElement('pre');
        pre.textContent = String(chunk.text).slice(0, 2400);
        details.appendChild(sum);
        details.appendChild(pre);
        row.appendChild(details);
      }

      debugResultsEl.appendChild(row);
    });
  }

  async function runRetrievalDebug(query, k) {
    const q = String(query || '').trim();
    const kk = Math.max(1, Math.min(25, Number(k || 8)));
    if (!q) {
      setDebugStatus('Enter a query first.', { error: true });
      return;
    }
    setDebugStatus('Running /docs/search (debug)â€¦');
    debugResultsEl.innerHTML = `<div class="tiny muted">Loadingâ€¦</div>`;
    try {
      const pack = await apiJson('/docs/search', {
        method: 'POST',
        body: { query: q, k: kk, debug: true, version: docsState.version || null },
      });
      lastRetrievalPack = pack;
      renderRetrievalDebug(pack);
      setDebugStatus('OK');
    } catch (e) {
      const raw = e?.raw ? String(e.raw) : String(e);
      setDebugStatus(`Failed: ${raw}`, { error: true });
      if (debugRawEl) debugRawEl.textContent = raw;
    }
  }

  debugRunBtn?.addEventListener('click', () => runRetrievalDebug(debugQueryEl?.value, debugKEl?.value));
  debugUseLastBtn?.addEventListener('click', () => {
    if (lastRetrievalPack) {
      renderRetrievalDebug(lastRetrievalPack);
      return;
    }
    runRetrievalDebug(lastUserMessage, chatKDefault);
  });
  debugQueryEl?.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      runRetrievalDebug(debugQueryEl.value, debugKEl?.value);
    }
  });

  async function refreshSessions() {
    historyList.innerHTML = `<div class="mini-item muted"><span class="slash">/</span> Loadingâ€¦</div>`;
    try {
      const data = await apiJson('/sessions');
      const sessions = data.sessions || [];
      historyList.innerHTML = '';

      const newItem = document.createElement('div');
      newItem.className = 'mini-item';
      newItem.innerHTML = `<span class="slash">/</span> New chat`;
      newItem.addEventListener('click', () => {
        session.session_id = null;
        thread.innerHTML = '';
        setEmptyStateVisible(true);
        historyPanel.classList.remove('visible');
      });
      historyList.appendChild(newItem);

      sessions.slice(0, 20).forEach((s) => {
        const item = document.createElement('div');
        item.className = 'mini-item';
        const slash = document.createElement('span');
        slash.className = 'slash';
        slash.textContent = '/';
        item.appendChild(slash);
        item.appendChild(document.createTextNode(` ${s.title || s.session_id}`));
        item.addEventListener('click', async () => {
          await loadSession(s.session_id);
          historyPanel.classList.remove('visible');
        });
        historyList.appendChild(item);
      });
    } catch (e) {
      historyList.innerHTML = '';
      const item = document.createElement('div');
      item.className = 'mini-item';
      item.innerHTML = `<span class="slash">/</span> Failed to load sessions`;
      historyList.appendChild(item);
    }
  }

	  async function loadSession(sessionId) {
    const data = await apiJson(`/sessions/${encodeURIComponent(sessionId)}/messages`);
    session.session_id = sessionId;
    thread.innerHTML = '';
    setEmptyStateVisible(true);
    const msgs = data.messages || [];
    msgs.forEach((m) => {
      appendMessage({ role: m.role, content: m.content });
      if (m.role === 'user') lastUserMessage = m.content;
      if (m.role === 'assistant') lastAssistantMessage = m.content;
    });
    if (msgs.length) setEmptyStateVisible(false);
  }

	  async function sendMessage() {
	    if (sendBtn.disabled || activeChatAbort) return;
	    const text = userInput.innerText.trim();
	    if (!text) return;

    userInput.innerText = '';
    lastUserMessage = text;
    appendMessage({ role: 'user', content: text });

	    sendBtn.disabled = true;
	    sendBtn.textContent = 'â€¦';

	    const pending = appendMessage({ role: 'assistant', content: '' });
	    pending.classList.add('pending');

	    let streamed = '';
	    let final = null;
	    let streamError = null;
	    let gotAnyEvent = false;
	    let userStopped = false;
	    let stoppedFinalized = false;

	    const pendingBody = pending.querySelector('.content');
	    if (pendingBody) {
	      pendingBody.innerHTML = `<div class="activity"><span class="spinner"></span><span class="activity-text"></span><button class="stop-btn" type="button">STOP</button></div><div class="stream-body"></div>`;
	    }
	    const pendingActivityTextEl = pending.querySelector('.activity-text');
	    const pendingStreamBodyEl = pending.querySelector('.stream-body');
	    const pendingStopBtnEl = pending.querySelector('.stop-btn');

	    function setPendingStatus(text) {
	      const body = pending.querySelector('.content');
	      if (!body) return;
	      const label = String(text || '');
	      if (pendingActivityTextEl) {
	        pendingActivityTextEl.textContent = label;
	      } else {
	        body.innerHTML = `<div class="activity"><span class="spinner"></span><span>${escapeHtml(label)}</span></div><div class="stream-body"></div>`;
	      }
	      thread.scrollTop = thread.scrollHeight;
	    }

	    let lastStreamRender = 0;
	    let streamRenderTimer = null;
	    function setPendingStream(mdText, { force = false } = {}) {
	      if (!pendingStreamBodyEl) return;
	      const now = performance.now ? performance.now() : Date.now();
	      const minGap = 120;
	      if (force || now - lastStreamRender >= minGap) {
	        lastStreamRender = now;
	        pendingStreamBodyEl.innerHTML = renderMarkdown(mdText || '');
	        thread.scrollTop = thread.scrollHeight;
	        return;
	      }
	      if (streamRenderTimer) return;
	      const delay = Math.max(0, minGap - (now - lastStreamRender));
	      streamRenderTimer = setTimeout(() => {
	        streamRenderTimer = null;
	        lastStreamRender = performance.now ? performance.now() : Date.now();
	        pendingStreamBodyEl.innerHTML = renderMarkdown(mdText || '');
	        thread.scrollTop = thread.scrollHeight;
	      }, delay);
	    }

	    const retrievalMode = adminBundle?.effective?.retrieval?.mode || 'bm25';
	    const modelId = (adminBundle?.effective?.llm?.model || '').trim() || 'LM Studio';
	    const webEnabled = Boolean(adminBundle?.effective?.web?.enabled ?? false);
	    const hasUrl = /https?:\/\/\S+/i.test(text);

	    setPendingStatus(
	      webEnabled && hasUrl
	        ? `Fetching web page + searching documentation (${retrievalMode})â€¦`
	        : `Searching documentation (${retrievalMode})â€¦`
	    );

	    try {
	      const k = Math.max(1, Math.min(25, Number(chatKDefault || 8)));

	      const payload = { message: text, k };
	      if (session.session_id) payload.session_id = session.session_id;

	      // Streaming: allow cancel.
	      const controller = new AbortController();
	      activeChatAbort = controller;
	      if (pendingStopBtnEl) {
	        pendingStopBtnEl.disabled = false;
	        pendingStopBtnEl.addEventListener('click', () => {
	          if (stoppedFinalized) return;
	          userStopped = true;
	          stoppedFinalized = true;
	          try { controller.abort(); } catch (e) {}
	          try {
	            pending.classList.remove('pending');
	            const body = pending.querySelector('.content');
	            if (body) {
	              const note = `<div class=\"tiny muted\" style=\"margin-top:10px;\">(generation stopped)</div>`;
	              body.innerHTML = renderMarkdown(streamed || '') + note;
	            }
	          } catch (e) {}
	        }, { once: true });
	      }

	      try {
	        await apiSse('/chat/stream', {
	          body: payload,
	          signal: controller.signal,
	          onEvent: (ev, data) => {
	            gotAnyEvent = true;
	            if (ev === 'status') {
	              const msg = data?.message ? String(data.message) : '';
	              setPendingStatus(msg || `Workingâ€¦ (${String(data?.phase || 'â€¦')})`);
	              if (data?.session_id && !session.session_id) session.session_id = String(data.session_id);
	            } else if (ev === 'retrieval') {
	              lastRetrievalPack = data;
	              const found = Array.isArray(data?.chunks) ? data.chunks.length : 0;
	              setPendingStatus(`Found ${found} relevant sections. Generating answer (${modelId})â€¦`);
	            } else if (ev === 'ping') {
	              const elapsed = typeof data?.elapsed_s === 'number' ? data.elapsed_s : null;
	              if (elapsed !== null) setPendingStatus(`Generating answer (${modelId})â€¦ ${elapsed}s`);
	            } else if (ev === 'delta') {
	              const d = data?.delta ? String(data.delta) : '';
	              if (d) {
	                streamed += d;
	                setPendingStream(streamed);
	              }
	            } else if (ev === 'final') {
	              final = data;
	            } else if (ev === 'error') {
	              streamError = data;
	            }
	          }
	        });
	      } catch (e) {
	        if (e?.name === 'AbortError' || userStopped) {
	          // User cancelled generation; keep partial output as-is.
	          if (!stoppedFinalized) {
	            try {
	              pending.classList.remove('pending');
	              const body = pending.querySelector('.content');
	              if (body) {
	                const note = `<div class=\"tiny muted\" style=\"margin-top:10px;\">(generation stopped)</div>`;
	                body.innerHTML = renderMarkdown(streamed || '') + note;
	              }
	            } catch (_) {}
	          }
	          return;
	        }

	        // Fallback to non-stream chat only if streaming isn't supported and nothing has started yet.
	        if (!gotAnyEvent && (e?.status === 404 || e?.status === 405 || e?.status === 501)) {
	          const data = await apiJson('/chat', { method: 'POST', body: payload });
	          pending.remove();
	          session.session_id = data.session_id;
	          lastAssistantMessage = data.answer || '';
	          saveHint.textContent = "Updated last answer target.";
	          appendMessage({
	            role: 'assistant',
	            content: data.answer || '',
	            citations: data.citations || [],
	            images: data.images || [],
	            web_sources: data.web_sources || [],
	            context_chunks: data.context_chunks || []
	          });
	          refreshSessions();
	          return;
	        }

	        throw e;
	      } finally {
	        activeChatAbort = null;
	      }

	      if (streamError) {
	        throw new Error(typeof streamError === 'string' ? streamError : JSON.stringify(streamError));
	      }
	      if (!final) {
	        throw new Error('Stream ended without final response.');
	      }

	      pending.remove();
	      session.session_id = final.session_id || session.session_id;
	      lastAssistantMessage = final.answer || '';
	      saveHint.textContent = "Updated last answer target.";
	      appendMessage({
	        role: 'assistant',
	        content: final.answer || streamed || '',
	        citations: final.citations || [],
	        images: final.images || [],
	        web_sources: final.web_sources || [],
	        context_chunks: final.context_chunks || []
	      });
	      refreshSessions();
	    } catch (e) {
	      pending.remove();
	      const raw = e?.raw ? String(e.raw) : String(e);
	      appendMessage({ role: 'assistant', content: 'Request failed.', errorText: raw });
	    } finally {
	      sendBtn.disabled = false;
	      sendBtn.textContent = 'SEND';
	    }
	  }

  sendBtn.addEventListener('click', sendMessage);
  userInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

	  // ---------- Modal control ----------
		  function closeAllModals() {
		    const wasDocs = docsPanel.classList.contains('visible');
		    if (wasDocs && docsState.editing && docsState.editDirty) {
		      if (!confirm('You have unsaved edits. Close anyway?')) return;
		    }
		    stopReindexPoll();
		    historyPanel.classList.remove('visible');
		    adminPanel.classList.remove('visible');
		    redactorPanel.classList.remove('visible');
		    docsPanel.classList.remove('visible');
		    debugPanel.classList.remove('visible');
		    userSettings.classList.remove('visible');
		    overlay.classList.remove('visible');
		    setDocsEditMode(false);
		    if (wasDocs && parseDocsHash()) {
		      try {
		        history.replaceState(null, '', location.pathname + location.search);
		      } catch (e) {
	        location.hash = '';
	      }
    }
  }
  function openModal(which) {
    historyPanel.classList.remove('visible');
    adminPanel.classList.remove('visible');
    redactorPanel.classList.remove('visible');
    docsPanel.classList.remove('visible');
    debugPanel.classList.remove('visible');

    which.classList.add('visible');
    overlay.classList.add('visible');
  }

  historyBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const willOpen = !historyPanel.classList.contains('visible');
    closeAllModals();
    if (willOpen) {
      historyPanel.classList.add('visible');
      refreshSessions();
    }
  });

	  toolsBtn.addEventListener('click', (e) => {
	    e.stopPropagation();
	    if (adminPanel.classList.contains('visible')) closeAllModals();
	    else {
	      openModal(adminPanel);
	      loadAdminPanel().catch((err) => {
	        adminSaveHintEl.textContent = `Failed to load settings: ${err?.raw ? String(err.raw) : String(err)}`;
	      });
	    }
	  });
		  topToolToggle.addEventListener('click', (e) => {
		    e.stopPropagation();
		    if (userSettings.classList.contains('visible')) userSettings.classList.remove('visible');
		    else userSettings.classList.add('visible');
		  });

  redactorBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (redactorPanel.classList.contains('visible')) closeAllModals();
    else {
      openModal(redactorPanel);
      renderList();
      saveHint.textContent = "";
    }
  });

  docsBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (docsPanel.classList.contains('visible')) closeAllModals();
    else {
      const deep = parseDocsHash();
      openDocsReader(deep || {});
    }
  });

  docsEditBtn?.addEventListener('click', async (e) => {
    e.stopPropagation();
    if (!docsState.page) {
      setDocsStatus('Select a page before editing.', { error: true });
      return;
    }
    if (docsState.editing) {
      if (docsState.editDirty && !confirm('You have unsaved edits. Exit edit mode?')) return;
      setDocsEditMode(false);
      return;
    }
    setDocsEditMode(true);
    try {
      await loadDocsEdit(docsState.page.doc_id, docsState.page.page_id);
    } catch (e2) {
      const raw = e2?.raw ? String(e2.raw) : String(e2);
      if (docsEditStatusEl) docsEditStatusEl.textContent = `Edit load failed: ${raw}`;
      setDocsEditMode(false);
    }
  });

  docsPdfBtn?.addEventListener('click', (e) => {
    e.stopPropagation();
    downloadDocsPdf();
  });

  debugBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (debugPanel.classList.contains('visible')) closeAllModals();
    else {
      openModal(debugPanel);
      if (debugQueryEl) debugQueryEl.value = String(lastUserMessage || '').trim();
      if (debugKEl) debugKEl.value = String(chatKDefault || 8);
      if (lastRetrievalPack) renderRetrievalDebug(lastRetrievalPack);
      else setDebugStatus('Tip: ask a question first, then USE LAST.', { error: false });
    }
  });

  overlay.addEventListener('click', () => closeAllModals());
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeAllModals(); });

  // user settings (not modal)
  userToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    userSettings.classList.toggle('visible');
  });

	  // Admin buttons (mock)
	  document.getElementById('adminOkBtn').addEventListener('click', closeAllModals);
	  docsOkBtn.addEventListener('click', closeAllModals);
	  debugOkBtn.addEventListener('click', closeAllModals);
	  document.getElementById('applyBtn').addEventListener('click', () => {
	    applyAdminSettings();
	    pulse(adminPanel);
	  });
	  document.getElementById('defaultsBtn').addEventListener('click', () => {
	    applyDefaultsToForm();
	    pulse(adminPanel);
	  });

  // Redactor OK
  document.getElementById('redactorOkBtn').addEventListener('click', closeAllModals);

  function pulse(el){
    el.style.transform = 'translateX(-50%) scale(0.995)';
    setTimeout(() => el.style.transform = 'translateX(-50%) scale(1)', 120);
  }

  // ---------- Redactor logic ----------
  confidenceEl.addEventListener('input', () => {
    confValEl.textContent = (confidenceEl.value/100).toFixed(2);
  });

  function getSelectedTags() {
    return Array.from(document.querySelectorAll('#tags input[type="checkbox"]:checked'))
      .map(x => x.value);
  }

  function makeId() {
    const t = new Date().toISOString();
    const n = String(annotations.length + 1).padStart(3,'0');
    return `msg_${t}_${n}`;
  }

  function resetFormLight() {
    rightEl.value = "";
    wrongEl.value = "";
    goldenEl.value = "";
    // keep score/tags/confidence as-is (faster for batch labeling)
  }

  saveBtn.addEventListener('click', () => {
    const item = {
      id: makeId(),
      ts: new Date().toISOString(),
      session_id: session.session_id,
      model: { ...session.model },
      input: {
        user: lastUserMessage,
        tool_context: { ...session.tool_context },
        attachments: []
      },
      output: { assistant: lastAssistantMessage },
      label: {
        score: Number(scoreEl.value),
        tags: getSelectedTags(),
        right: rightEl.value.trim(),
        wrong: wrongEl.value.trim(),
        golden_fix: goldenEl.value.trim(),
        reviewer_confidence: Number(confidenceEl.value)/100
      }
    };

    annotations.push(item);
    saveHint.textContent = `Saved annotation #${annotations.length}`;
    renderList();
    resetFormLight();
  });

  filterTag.addEventListener('change', renderList);
  sortBy.addEventListener('change', renderList);

  function renderList() {
    let items = [...annotations];

    const ft = filterTag.value;
    if (ft) items = items.filter(a => (a.label.tags || []).includes(ft));

    switch (sortBy.value) {
      case "oldest": items.sort((a,b) => a.ts.localeCompare(b.ts)); break;
      case "score_low": items.sort((a,b) => a.label.score - b.label.score); break;
      case "score_high": items.sort((a,b) => b.label.score - a.label.score); break;
      default: items.sort((a,b) => b.ts.localeCompare(a.ts));
    }

    if (items.length === 0) {
      annoList.innerHTML = `<div class="tiny muted">No annotations yet. Save one and the pile will begin.</div>`;
      return;
    }

    annoList.innerHTML = items.map(a => {
      const tagStr = (a.label.tags || []).slice(0,3).join(", ");
      const more = (a.label.tags || []).length > 3 ? ` +${(a.label.tags||[]).length-3}` : "";
      return `
        <div class="item" data-id="${a.id}">
          <div class="top">
            <span class="badge score">score: ${a.label.score}</span>
            <span class="badge">${new Date(a.ts).toLocaleString()}</span>
          </div>
          <div class="tagline">tags: ${tagStr}${more}</div>
          <div class="tagline">golden_fix: ${a.label.golden_fix ? "yes" : "no"}</div>
        </div>
      `;
    }).join("");

    // click to load into form for editing (simple: populate fields)
    document.querySelectorAll('.item').forEach(el => {
      el.addEventListener('click', () => {
        const id = el.getAttribute('data-id');
        const a = annotations.find(x => x.id === id);
        if (!a) return;

        scoreEl.value = String(a.label.score);
        // set tags
        document.querySelectorAll('#tags input[type="checkbox"]').forEach(cb => {
          cb.checked = (a.label.tags || []).includes(cb.value);
        });
        rightEl.value = a.label.right || "";
        wrongEl.value = a.label.wrong || "";
        goldenEl.value = a.label.golden_fix || "";
        confidenceEl.value = Math.round((a.label.reviewer_confidence || 0) * 100);
        confValEl.textContent = (confidenceEl.value/100).toFixed(2);
        saveHint.textContent = `Loaded ${id} into form (save again to create a new entry).`;
      });
    });
  }

  // ---------- Export ----------
  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function toExportObjects() {
    const includeContext = includeContextEl.checked;

    return annotations.map(a => {
      if (includeContext) return a;
      // strip to essentials
      return {
        id: a.id,
        ts: a.ts,
        model: a.model,
        input: { user: a.input.user },
        output: a.output,
        label: a.label
      };
    });
  }

  document.getElementById('exportJsonlBtn').addEventListener('click', () => {
    const objs = toExportObjects();
    const jsonl = objs.map(o => JSON.stringify(o)).join("\n") + "\n";
    downloadText(`annotations_${new Date().toISOString().slice(0,10)}.jsonl`, jsonl);
  });

  function csvEscape(v) {
    const s = String(v ?? "");
    if (/[",\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }

  document.getElementById('exportCsvBtn').addEventListener('click', () => {
    const objs = toExportObjects();
    const header = [
      "id","ts","model_id","temp","top_k","top_p",
      "user","assistant","score","tags","right","wrong","golden_fix","reviewer_confidence"
    ];
    const rows = objs.map(o => ([
      o.id,
      o.ts,
      o.model?.id ?? "",
      o.model?.temp ?? "",
      o.model?.top_k ?? "",
      o.model?.top_p ?? "",
      o.input?.user ?? "",
      o.output?.assistant ?? "",
      o.label?.score ?? "",
      (o.label?.tags ?? []).join("|"),
      o.label?.right ?? "",
      o.label?.wrong ?? "",
      o.label?.golden_fix ?? "",
      o.label?.reviewer_confidence ?? ""
    ]).map(csvEscape).join(","));
    const csv = header.join(",") + "\n" + rows.join("\n") + "\n";
    downloadText(`annotations_${new Date().toISOString().slice(0,10)}.csv`, csv);
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    annotations.length = 0;
    renderList();
    saveHint.textContent = "Cleared annotation list.";
  });

	  // Init
	  refreshAuth();
	  renderList();
	  (async () => {
	    const deep = parseDocsHash();
	    if (deep) await openDocsReader(deep);
	  })();
  (function initDocsTheme() {
    try {
      const t = localStorage.getItem('luxriot_docs_theme') || 'dark';
      setDocsTheme(t);
    } catch (e) {}
  })();
  (function initDocsNav() {
    initDocsNavState();
    setDocsScrollLock(false);
  })();
</script>
</body>
</html>
